# Section: Introduction to Routing in React with React Router

## Overview of Routing

### Definition
Routing in React allows navigation between different components or pages in a single-page application (SPA) without full page reloads.

### Purpose
Routing enables users to move between different views (e.g., home page, activity list, activity details) in a React application, improving user experience by making navigation seamless.

### Key Idea
React Router is the standard library for handling routing in React, providing components like `BrowserRouter`, `Route`, and `Outlet` to manage navigation.

> **Analogy**: Think of routing as a map for your app. Each route is like a road leading to a specific destination (component), and React Router is the GPS guiding users to the right place.

## Learning Goals
- **Understand React Router**: Learn how to set up React Router in a React application.
- **Configure Routes**: Define routes to navigate to different components.
- **Implement Navigation**: Use `NavLink` and `Link` components to create clickable navigation elements.
- **Handle Dynamic Routes**: Create routes with parameters (e.g., `/activities/:id`) to display specific data.

## Setting Up React Router

### Installation
- Install React Router using the command:
  ```bash
  npm install react-router-dom
  ```
- This adds React Router to your project, enabling routing functionality.

### Configuring the Router
- Create a `router` folder in `src/app` and add a `routes.tsx` file to define routes.
- Use `createBrowserRouter` from `react-router-dom` to set up the router.
- Example:
  ```tsx
  import { createBrowserRouter } from 'react-router-dom';
  import App from '../App';
  import HomePage from '../../features/home/HomePage';
  import ActivityDashboard from '../../features/activities/dashboard/ActivityDashboard';
  import ActivityForm from '../../features/activities/form/ActivityForm';

  export const router = createBrowserRouter([
    {
      path: '/',
      element: <App />,
      children: [
        { path: '', element: <HomePage /> },
        { path: 'activities', element: <ActivityDashboard /> },
        { path: 'createActivity', element: <ActivityForm /> },
      ],
    },
  ]);
  ```
- The root route (`/`) renders the `App` component, which acts as the parent for child routes.
- Child routes define specific paths (e.g., `''` for the homepage, `activities` for the activity list).

### Integrating Router in the App
- In `main.tsx`, replace the direct rendering of `App` with `RouterProvider` to enable routing.
- Example:
  ```tsx
  import ReactDOM from 'react-dom/client';
  import { RouterProvider } from 'react-router-dom';
  import { router } from './app/router/routes';

  ReactDOM.createRoot(document.getElementById('root')!).render(
    <RouterProvider router={router} />
  );
  ```
- The `RouterProvider` wraps the app, making routing available throughout.

### Using Outlet
- In `App.tsx`, replace direct component rendering with `<Outlet />` from `react-router-dom`.
- The `Outlet` component acts as a placeholder where child route components are rendered.
- Example:
  ```tsx
  import { Outlet } from 'react-router-dom';
  import { Container } from '@mui/material';

  function App() {
    return (
      <Container style={{ marginTop: '3rem' }}>
        <Outlet />
      </Container>
    );
  }
  ```
- When a route is activated (e.g., `/activities`), the corresponding component (e.g., `ActivityDashboard`) replaces the `Outlet`.

## Creating Navigation Links

### NavLink Component
- Use `NavLink` from `react-router-dom` to create clickable links that navigate to specific routes.
- `NavLink` automatically applies an `active` class when the route matches the current URL, useful for styling.
- Example in `NavBar.tsx`:
  ```tsx
  import { NavLink } from 'react-router-dom';
  import { MenuItem } from '@mui/material';

  function NavBar() {
    return (
      <>
        <MenuItem component={NavLink} to="/">Reactivities</MenuItem>
        <MenuItem component={NavLink} to="/activities">Activities</MenuItem>
        <MenuItem component={NavLink} to="/createActivity">Create Activity</MenuItem>
      </>
    );
  }
  ```
- The `to` prop specifies the route path (e.g., `/activities`).

### Styling Active Links
- Create a reusable `MenuItemLink` component to style active `NavLink` components.
- Example in `MenuItemLink.tsx`:
  ```tsx
  import { MenuItem } from '@mui/material';
  import { NavLink } from 'react-router-dom';

  interface Props {
    children: React.ReactNode;
    to: string;
  }

  function MenuItemLink({ children, to }: Props) {
    return (
      <MenuItem
        component={NavLink}
        to={to}
        sx={{
          fontSize: '1.2rem',
          textTransform: 'uppercase',
          fontWeight: 'bold',
          color: 'inherit',
          '&.active': {
            color: 'yellow',
          },
        }}
      >
        {children}
      </MenuItem>
    );
  }

  export default MenuItemLink;
  ```
- Use in `NavBar.tsx`:
  ```tsx
  import MenuItemLink from '../shared/components/MenuItemLink';

  function NavBar() {
    return (
      <>
        <MenuItemLink to="/">Reactivities</MenuItemLink>
        <MenuItemLink to="/activities">Activities</MenuItemLink>
        <MenuItemLink to="/createActivity">Create Activity</MenuItemLink>
      </>
    );
  }
  ```
- The `&.active` selector styles the link when it’s active (e.g., yellow text).

## Dynamic Routing for Activity Details

### Defining Dynamic Routes
- Add a route with a parameter (e.g., `:id`) to handle specific resources, like an activity details page.
- Example in `routes.tsx`:
  ```tsx
  { path: 'activities/:id', element: <ActivityDetail /> },
  ```
- The `:id` is a placeholder for the activity’s ID in the URL (e.g., `/activities/123`).

### Linking to Dynamic Routes
- In `ActivityCard.tsx`, use the `Link` component to navigate to the details page with the activity’s ID.
- Example:
  ```tsx
  import { Link } from 'react-router-dom';
  import { Button } from '@mui/material';

  interface Props {
    activity: { id: string; title: string };
  }

  function ActivityCard({ activity }: Props) {
    return (
      <div>
        <h3>{activity.title}</h3>
        <Button component={Link} to={`/activities/${activity.id}`}>
          View
        </Button>
      </div>
    );
  }
  ```
- The `to` prop uses the activity’s ID to form the URL (e.g., `/activities/123`).

### Navigating Programmatically
- Use the `useNavigate` hook for programmatic navigation, such as redirecting after an action.
- Example in `ActivityDetail.tsx`:
  ```tsx
  import { useNavigate } from 'react-router-dom';
  import { Button } from '@mui/material';

  function ActivityDetail() {
    const navigate = useNavigate();

    return (
      <div>
        <Button onClick={() => navigate('/activities')}>
          Cancel
        </Button>
      </div>
    );
  }
  ```
- Clicking the “Cancel” button navigates back to `/activities`.

## Key Commands Recap
- `npm install react-router-dom`: Installs React Router.
- `createBrowserRouter`: Defines the routing configuration.
- `<RouterProvider router={router} />`: Integrates the router into the app.
- `<Outlet />`: Renders child route components.
- `<NavLink to="/path">`: Creates a link with active state styling.
- `<Link to="/path">`: Creates a link without active state styling.
- `useNavigate()`: Enables programmatic navigation.

## Tips for Beginners
- **Always Use Absolute Paths**: Prefix routes with `/` (e.g., `/activities`) to avoid appending routes incorrectly.
- **Simplify Props**: Avoid passing props through routes; use hooks or context for data management.
- **Check Active Styling**: Use the `active` class in `NavLink` to highlight the current route.
- **Test Routes Early**: Verify routes work by manually entering URLs in the browser before adding links.

## Next Steps
- Learn how to fetch data for dynamic routes (e.g., fetching an activity by ID in `ActivityDetail`).
- Explore React Query for cache management and background data fetching.
- Enhance the UI for the activity details page to improve its appearance.

# Section: Advanced Routing and Form Handling in React with React Router

## Fetching Individual Activities with React Query

### Definition
Fetching individual activities involves retrieving a specific activity from the API using its ID, which is obtained from the URL via React Router’s `useParams` hook.

### Purpose
This allows the application to display detailed information about a specific activity (e.g., on an activity details page) and populate forms for editing, enhancing the user experience.

### Key Idea
React Router’s `useParams` hook extracts dynamic route parameters (e.g., `:id`), which can be used with React Query to fetch specific data from the API.

> **Analogy**: Think of the activity ID in the URL as a library book’s call number. `useParams` finds the call number, and React Query fetches the exact book (activity) from the API shelf.

## Learning Goals
- **Extract Route Parameters**: Use `useParams` to get the activity ID from the URL.
- **Fetch Individual Activities**: Extend the `useActivities` hook to fetch a single activity by ID.
- **Handle Form Navigation**: Redirect users to appropriate routes after creating or updating activities.
- **Reset Forms**: Ensure forms reset correctly when navigating between create and edit modes.

## Fetching an Individual Activity

### Updating the `useActivities` Hook
- Modify the `useActivities` hook to optionally fetch a single activity by ID.
- Use React Query’s `useQuery` with an `enabled` option to prevent unnecessary API calls when no ID is provided.
- Example in `useActivities.ts`:
  ```tsx
  import { useQuery } from '@tanstack/react-query';
  import agent from '../api/agent';

  interface Activity {
    id: string;
    title: string;
    // other activity properties
  }

  export function useActivities(id?: string) {
    const { data: activities, isLoading } = useQuery({
      queryKey: ['activities'],
      queryFn: async () => {
        const response = await agent.get('/activities');
        return response.data as Activity[];
      },
    });

    const { data: activity, isLoading: isLoadingActivity } = useQuery({
      queryKey: ['activities', id],
      queryFn: async () => {
        const response = await agent.get(`/activities/${id}`);
        return response.data as Activity;
      },
      enabled: !!id, // Only fetch if id is provided
    });

    return { activities, isLoading, activity, isLoadingActivity };
  }
  ```
- The `enabled: !!id` ensures the query only runs when an `id` is provided, preventing unnecessary API calls (e.g., `/activities/undefined`).
- The `queryKey: ['activities', id]` uniquely identifies the query for caching.

### Using `useParams` in Activity Details
- In `ActivityDetail.tsx`, use `useParams` to extract the `id` from the URL and pass it to `useActivities`.
- Display a loading state or error if the activity isn’t found.
- Example:
  ```tsx
  import { useParams } from 'react-router-dom';
  import { Typography } from '@mui/material';
  import { useActivities } from '../../hooks/useActivities';

  function ActivityDetail() {
    const { id } = useParams<{ id: string }>();
    const { activity, isLoadingActivity } = useActivities(id);

    if (isLoadingActivity) return <Typography>Loading...</Typography>;
    if (!activity) return <Typography>Activity not found</Typography>;

    return (
      <div>
        <Typography variant="h3">{activity.title}</Typography>
        {/* Display other activity details */}
      </div>
    );
  }
  ```
- The `id` from `useParams` matches the `:id` in the route path (e.g., `/activities/:id`).

## Handling Activity Form Navigation

### Adding an Edit Route
- Add a route for editing an activity in `routes.tsx`, reusing the `ActivityForm` component.
- Example:
  ```tsx
  import ActivityForm from '../../features/activities/form/ActivityForm';
  import ActivityDetail from '../../features/activities/details/ActivityDetail';

  export const router = createBrowserRouter([
    {
      path: '/',
      element: <App />,
      children: [
        { path: '', element: <HomePage /> },
        { path: 'activities', element: <ActivityDashboard /> },
        { path: 'activities/:id', element: <ActivityDetail /> },
        { path: 'createActivity', element: <ActivityForm key="create" /> },
        { path: 'manage/:id', element: <ActivityForm key="manage" /> },
      ],
    },
  ]);
  ```
- The `key` prop ensures React treats `createActivity` and `manage/:id` as distinct instances, forcing the form to reset when switching routes.

### Updating ActivityDetail for Editing
- Update the “Edit” button in `ActivityDetail.tsx` to navigate to the `manage/:id` route.
- Example:
  ```tsx
  import { Link } from 'react-router-dom';
  import { Button } from '@mui/material';

  function ActivityDetail() {
    const { id } = useParams<{ id: string }>();
    const { activity, isLoadingActivity } = useActivities(id);

    if (isLoadingActivity) return <Typography>Loading...</Typography>;
    if (!activity) return <Typography>Activity not found</Typography>;

    return (
      <div>
        <Typography variant="h3">{activity.title}</Typography>
        <Button component={Link} to={`/manage/${activity.id}`}>
          Edit
        </Button>
        <Button onClick={() => navigate('/activities')}>
          Cancel
        </Button>
      </div>
    );
  }
  ```

### Enhancing the Activity Form
- In `ActivityForm.tsx`, fetch the activity using `useActivities` and `useParams` for editing, and handle form submission with navigation.
- Update the form title to reflect whether it’s creating or editing.
- Example:
  ```tsx
  import { useParams, useNavigate } from 'react-router-dom';
  import { Typography, Button } from '@mui/material';
  import { useActivities } from '../../hooks/useActivities';

  function ActivityForm() {
    const { id } = useParams<{ id: string }>();
    const { activity, isLoadingActivity, updateActivity, createActivity } = useActivities(id);
    const navigate = useNavigate();

    if (isLoadingActivity) return <Typography>Loading activity...</Typography>;

    const handleSubmit = () => {
      if (id && activity) {
        updateActivity(activity).then(() => {
          navigate(`/activities/${activity.id}`);
        });
      } else {
        createActivity(activity).then((data) => {
          navigate(`/activities/${data.id}`);
        });
      }
    };

    return (
      <div>
        <Typography variant="h3">{id ? 'Edit Activity' : 'Create Activity'}</Typography>
        {/* Form fields */}
        <Button onClick={handleSubmit}>Submit</Button>
      </div>
    );
  }
  ```
- The form checks for an `id` to determine if it’s editing or creating.
- After submission, `navigate` redirects to the activity details page using the activity’s ID.

### Handling Create Activity Response
- Update the `useActivities` hook to return the created activity’s ID from the `createActivity` mutation.
- Example in `useActivities.ts`:
  ```tsx
  import { useMutation } from '@tanstack/react-query';

  export function useActivities(id?: string) {
    // ... existing queries ...

    const { mutate: createActivity } = useMutation({
      mutationFn: async (activity: Activity) => {
        const response = await agent.post('/activities', activity);
        return response.data as Activity; // Return the created activity
      },
    });

    return { activities, isLoading, activity, isLoadingActivity, createActivity };
  }
  ```
- In `ActivityForm.tsx`, use the mutation’s `onSuccess` to navigate with the created activity’s ID:
  ```tsx
  const handleSubmit = () => {
    if (id && activity) {
      updateActivity(activity).then(() => {
        navigate(`/activities/${activity.id}`);
      });
    } else {
      createActivity(activity, {
        onSuccess: (data) => {
          navigate(`/activities/${data.id}`);
        },
      });
    }
  };
  ```

## Resetting the Form with Keys

### Issue with Form Reuse
- When navigating from `/manage/:id` to `/createActivity`, the `ActivityForm` component doesn’t reset because React reuses the same instance.
- Solution: Use the `key` prop in `routes.tsx` to force React to unmount and remount the component.

### Implementation
- In `routes.tsx`, the `key` prop ensures distinct component instances:
  ```tsx
  { path: 'createActivity', element: <ActivityForm key="create" /> },
  { path: 'manage/:id', element: <ActivityForm key="manage" /> },
  ```
- When navigating to `/createActivity`, the `key="create"` forces a new instance, resetting the form.

### Updating Form Title
- In `ActivityForm.tsx`, dynamically set the title based on the presence of an `id`:
  ```tsx
  <Typography variant="h3">{id ? 'Edit Activity' : 'Create Activity'}</Typography>
  ```

## Key Commands Recap
- `useParams()`: Extracts route parameters (e.g., `id`) from the URL.
- `useQuery({ enabled: !!id })`: Conditionally runs a query based on the presence of an ID.
- `useMutation({ onSuccess })`: Handles API responses and triggers navigation.
- `navigate('/path')`: Programmatically navigates to a route.
- `key="unique"`: Forces React to treat components as distinct instances.

## Tips for Beginners
- **Match Parameter Names**: Ensure the parameter name in `useParams` (e.g., `id`) matches the route path (e.g., `:id`).
- **Use Enabled Option**: Prevent unnecessary API calls by using `enabled: !!id` in `useQuery`.
- **Test Navigation**: Manually test routes (e.g., `/activities/123`) to ensure components load correctly.
- **Leverage Keys**: Use the `key` prop to reset forms or components when navigating between similar routes.
- **Check Cache Behavior**: Use React Query’s dev tools to verify which queries are running or cached.

## Next Steps
- Style the `ActivityDetail` and `ActivityForm` components for better user experience.
- Explore React Query’s cache invalidation and stale time settings for optimized data fetching.
- Add authentication to manage user-specific routes and actions.
- Commit changes to source control to mark the completion of the routing section.