# Section 16: Implementing Image Uploads in the API

## Overview

### Definition
This section covers implementing image upload functionality in the API using Cloudinary, a cloud-based image storage service, to store and manage user profile photos.

### Purpose
To enable users to upload, delete, and set main profile photos, integrating Cloudinary with a clean architecture approach to abstract storage details and ensure scalability.

### Key Idea
The API uses Cloudinary to handle image uploads, storing only URLs and IDs in the database, while maintaining clean architecture by abstracting storage logic in the infrastructure layer.

> **Analogy**: Think of Cloudinary as a digital photo album stored in the cloud. Your application hands over photos to this album, gets back a web address to display them, and doesn’t worry about where or how the album stores them.

## Learning Goals
- **Explore Image Storage Options**: Understand the pros and cons of storing images in a database, file system, or cloud service like Cloudinary.
- **Implement Cloudinary Integration**: Set up Cloudinary in the API with secure configuration and service implementation.
- **Create Photo Management Handlers**: Build handlers for uploading, deleting, and setting main photos, and retrieving user profiles.
- **Maintain Clean Architecture**: Abstract image storage logic to the infrastructure layer, keeping the application layer independent.

## Image Storage Options

### Definition
Evaluate different options for storing images in the application.

### Options and Considerations
- **Database Storage**:
  - Stores images as Binary Large Objects (BLOBs).
  - **Pros**: Easy authentication, as it’s just another database resource.
  - **Cons**: Inefficient for file storage, consumes significant database space, and retrieval is slow.
- **File System Storage**:
  - Stores images directly on the server’s file system.
  - **Pros**: Designed for file storage, straightforward to implement.
  - **Cons**: Limited by server disk space, potential issues with cloud hosting permissions, and server crashes if space runs out.
- **Cloud Service (Cloudinary)**:
  - Uses a third-party service for scalable image storage.
  - **Pros**: Highly scalable, no server space concerns, supports image transformations, secure via API keys.
  - **Cons**: Potentially higher costs for large-scale use, requires API key management.

### Key Idea
Cloudinary is chosen for its scalability, generous free tier (25GB storage, 25,000 transformations), and ability to abstract storage details, aligning with clean architecture principles.

## Setting Up Cloudinary

### Definition
Configure Cloudinary in the API to enable image uploads, securing credentials in configuration files.

### Implementation
- **Sign Up for Cloudinary**: Create a free account at [Cloudinary](https://cloudinary.com) and verify your email. No credit card required.
- **Retrieve API Credentials**:
  - Access Cloudinary dashboard to obtain `CloudName`, `ApiKey`, and `ApiSecret`.
- **Configure in `appsettings.json`**:
  ```json
  {
    "CloudinarySettings": {
      "CloudName": "",
      "ApiKey": "",
      "ApiSecret": ""
    }
  }
  ```
  - Store in `appsettings.json` (excluded from GitHub via `.gitignore`) to prevent public exposure.
- **Create Configuration Class**:
  - In `Infrastructure/Photos/CloudinarySettings.cs`:
    ```csharp
    public class CloudinarySettings
    {
        public required string CloudName { get; set; }
        public required string ApiKey { get; set; }
        public required string ApiSecret { get; set; }
    }
    ```
- **Register Configuration in `Program.cs`**:
  ```csharp
  builder.Services.Configure<CloudinarySettings>(builder.Configuration.GetSection("CloudinarySettings"));
  ```
- **Install Cloudinary NuGet Package**:
  ```bash
  dotnet add package CloudinaryDotNet
  ```
  - Install in the `Infrastructure` project to access Cloudinary functionality.

### Key Idea
Securely storing Cloudinary credentials in `appsettings.json` and using a typed configuration class ensures type safety and prevents runtime errors due to typos.

## Creating Photo Service

### Definition
Implement a photo service to handle image uploads and deletions, abstracting Cloudinary logic in the infrastructure layer.

### Implementation
- **Create DTO in `Application/Profiles/Dtos/PhotoUploadResult.cs`**:
  ```csharp
  public class PhotoUploadResult
  {
      public required string PublicId { get; set; }
      public required string Url { get; set; }
  }
  ```
- **Create Interface in `Application/Interfaces/IPhotoService.cs`**:
  ```csharp
  using Microsoft.AspNetCore.Http;

  public interface IPhotoService
  {
      Task<PhotoUploadResult?> UploadPhoto(IFormFile file);
      Task<string> DeletePhoto(string publicId);
  }
  ```
  - Add framework reference in `Application.csproj` to support `IFormFile`:
    ```xml
    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
    ```
- **Implement Service in `Infrastructure/Photos/PhotoService.cs`**:
  ```csharp
  using CloudinaryDotNet;
  using CloudinaryDotNet.Actions;
  using Microsoft.Extensions.Options;

  public class PhotoService : IPhotoService
  {
      private readonly Cloudinary _cloudinary;

      public PhotoService(IOptions<CloudinarySettings> config)
      {
          var account = new Account(
              config.Value.CloudName,
              config.Value.ApiKey,
              config.Value.ApiSecret
          );
          _cloudinary = new Cloudinary(account);
      }

      public async Task<PhotoUploadResult?> UploadPhoto(IFormFile file)
      {
          if (file.Length > 0)
          {
              using var stream = file.OpenReadStream();
              var uploadParams = new ImageUploadParams
              {
                  File = new FileDescription(file.FileName, stream),
                  Folder = "Reactivities2025"
              };
              var uploadResult = await _cloudinary.UploadAsync(uploadParams);
              if (uploadResult.Error != null)
                  throw new Exception(uploadResult.Error.Message);
              return new PhotoUploadResult
              {
                  PublicId = uploadResult.PublicId,
                  Url = uploadResult.SecureUrl.AbsoluteUri
              };
          }
          return null;
      }

      public async Task<string> DeletePhoto(string publicId)
      {
          var deleteParams = new DeletionParams(publicId);
          var result = await _cloudinary.DestroyAsync(deleteParams);
          if (result.Error != null)
              throw new Exception(result.Error.Message);
          return result.Result;
      }
  }
  ```
- **Register Service in `Program.cs`**:
  ```csharp
  builder.Services.AddScoped<IPhotoService, PhotoService>();
  ```

### Key Idea
The `PhotoService` abstracts Cloudinary interactions, allowing the application layer to focus on business logic without knowing storage details.

## Database Integration

### Definition
Create a `Photo` entity and configure its relationship with the `User` entity to store photo metadata in the database.

### Implementation
- **Create `Photo` Entity in `Domain/Photo.cs`**:
  ```csharp
  public class Photo
  {
      public Guid Id { get; set; } = Guid.NewGuid().ToString();
      public required string Url { get; set; }
      public required string PublicId { get; set; }
      public required string UserId { get; set; }
      public User? User { get; set; }
  }
  ```
- **Update `User` Entity in `Domain/User.cs`**:
  ```csharp
  public List<Photo> Photos { get; set; } = new();
  ```
- **Add DbSet in `Persistence/AppDbContext.cs`**:
  ```csharp
  public required DbSet<Photo> Photos { get; set; }
  ```
- **Create Migration**:
  ```bash
  dotnet ef migrations add PhotoEntityAdded -p Persistence -s API
  ```
  - Configure cascade delete for user-photo relationship to automatically delete photos when a user is deleted.
  - Alternatively, leave as nullable for manual cleanup to avoid Cloudinary sync issues.

### Key Idea
The `Photo` entity stores metadata (URL, PublicId) in the database, with a one-to-many relationship to `User`, allowing flexible management of photos.

## Photo Handlers

### Definition
Create handlers for adding, deleting, setting main photos, and retrieving user profiles.

### Add Photo Handler
- **In `Application/Profiles/Commands/AddPhoto.cs`**:
  ```csharp
  public class AddPhoto
  {
      public class Command : IRequest<Result<Photo>>
      {
          public required IFormFile File { get; set; }
      }

      public class Handler : IRequestHandler<Command, Result<Photo>>
      {
          private readonly AppDbContext _context;
          private readonly IUserAccessor _userAccessor;
          private readonly IPhotoService _photoService;

          public Handler(AppDbContext context, IUserAccessor userAccessor, IPhotoService photoService)
          {
              _context = context;
              _userAccessor = userAccessor;
              _photoService = photoService;
          }

          public async Task<Result<Photo>> Handle(Command request, CancellationToken cancellationToken)
          {
              var uploadResult = await _photoService.UploadPhoto(request.File);
              if (uploadResult == null)
                  return Result<Photo>.Failure("Failed to upload photo", 400);

              var user = await _userAccessor.GetUserAsync();
              var photo = new Photo
              {
                  Url = uploadResult.Url,
                  PublicId = uploadResult.PublicId,
                  UserId = user.Id
              };
              user.ImageUrl ??= photo.Url;

              _context.Photos.Add(photo);
              var result = await _context.SaveChangesAsync(cancellationToken) > 0;
              return result ? Result<Photo>.Success(photo) : Result<Photo>.Failure("Problem saving photo to DB", 400);
          }
      }
  }
  ```

### Delete Photo Handler
- **In `Application/Profiles/Commands/DeletePhoto.cs`**:
  ```csharp
  public class DeletePhoto
  {
      public class Command : IRequest<Result<Unit>>
      {
          public required string PhotoId { get; set; }
      }

      public class Handler : IRequestHandler<Command, Result<Unit>>
      {
          private readonly AppDbContext _context;
          private readonly IUserAccessor _userAccessor;
          private readonly IPhotoService _photoService;

          public Handler(AppDbContext context, IUserAccessor userAccessor, IPhotoService photoService)
          {
              _context = context;
              _userAccessor = userAccessor;
              _photoService = photoService;
          }

          public async Task<Result<Unit>> Handle(Command request, CancellationToken cancellationToken)
          {
              var user = await _userAccessor.GetUserWithPhotosAsync();
              var photo = user.Photos.FirstOrDefault(x => x.Id == request.PhotoId);
              if (photo == null)
                  return Result<Unit>.Failure("Cannot find photo", 400);
              if (photo.Url == user.ImageUrl)
                  return Result<Unit>.Failure("Cannot delete main photo", 400);

              await _photoService.DeletePhoto(photo.PublicId);
              user.Photos.Remove(photo);
              var result = await _context.SaveChangesAsync(cancellationToken) > 0;
              return result ? Result<Unit>.Success(Unit.Value) : Result<Unit>.Failure("Problem deleting photo", 400);
          }
      }
  }
  ```
- **Update `IUserAccessor` and `UserAccessor`**:
  ```csharp
  public interface IUserAccessor
  {
      Task<User> GetUserAsync();
      Task<User> GetUserWithPhotosAsync();
  }

  public class UserAccessor : IUserAccessor
  {
      public async Task<User> GetUserWithPhotosAsync()
      {
          var userId = GetUserId();
          return await _context.Users
              .Include(x => x.Photos)
              .FirstOrDefaultAsync(x => x.Id == userId);
      }
  }
  ```

### Set Main Photo Handler
- **In `Application/Profiles/Commands/SetMainPhoto.cs`**:
  ```csharp
  public class SetMainPhoto
  {
      public class Command : IRequest<Result<Unit>>
      {
          public required string PhotoId { get; set; }
      }

      public class Handler : IRequestHandler<Command, Result<Unit>>
      {
          private readonly AppDbContext _context;
          private readonly IUserAccessor _userAccessor;

          public Handler(AppDbContext context, IUserAccessor userAccessor)
          {
              _context = context;
              _userAccessor = userAccessor;
          }

          public async Task<Result<Unit>> Handle(Command request, CancellationToken cancellationToken)
          {
              var user = await _userAccessor.GetUserWithPhotosAsync();
              var photo = user.Photos.FirstOrDefault(x => x.Id == request.PhotoId);
              if (photo == null)
                  return Result<Unit>.Failure("Cannot find photo", 400);

              user.ImageUrl = photo.Url;
              var result = await _context.SaveChangesAsync(cancellationToken) > 0;
              return result ? Result<Unit>.Success(Unit.Value) : Result<Unit>.Failure("Problem updating photo", 400);
          }
      }
  }
  ```

### Get Profile Photos Handler
- **In `Application/Profiles/Queries/GetProfilePhotos.cs`**:
  ```csharp
  public class GetProfilePhotos
  {
      public class Query : IRequest<Result<List<Photo>>>
      {
          public string UserId { get; set; }
      }

      public class Handler : IRequestHandler<Query, Result<List<Photo>>>
      {
          private readonly AppDbContext _context;

          public Handler(AppDbContext context)
          {
              _context = context;
          }

          public async Task<Result<List<Photo>>> Handle(Query request, CancellationToken cancellationToken)
          {
              var photos = await _context.Users
                  .Where(x => x.Id == request.UserId)
                  .SelectMany(x => x.Photos)
                  .ToListAsync(cancellationToken);
              return Result<List<Photo>>.Success(photos);
          }
      }
  }
  ```

### Get Profile Handler
- **In `Application/Profiles/Queries/GetProfile.cs`**:
  ```csharp
  public class GetProfile
  {
      public class Query : IRequest<Result<UserProfile>>
      {
          public required string UserId { get; set; }
      }

      public class Handler : IRequestHandler<Query, Result<UserProfile>>
      {
          private readonly AppDbContext _context;
          private readonly IMapper _mapper;

          public Handler(AppDbContext context, IMapper mapper)
          {
              _context = context;
              _mapper = mapper;
          }

          public async Task<Result<UserProfile>> Handle(Query request, CancellationToken cancellationToken)
          {
              var profile = await _context.Users
                  .ProjectTo<UserProfile>(_mapper.ConfigurationProvider)
                  .SingleOrDefaultAsync(x => x.Id == request.UserId, cancellationToken);
              return profile == null
                  ? Result<UserProfile>.Failure("Profile not found", 404)
                  : Result<UserProfile>.Success(profile);
          }
      }
  }
  ```
- **Update Mapping Profile in `Application/Core/MappingProfiles.cs`**:
  ```csharp
  CreateMap<User, UserProfile>();
  ```

### Key Idea
Handlers encapsulate business logic for photo management, ensuring robust error handling and database interactions while maintaining clean architecture.

## API Controller

### Definition
Create a `ProfilesController` to expose endpoints for photo and profile operations.

### Implementation
- **In `API/Controllers/ProfilesController.cs`**:
  ```csharp
  public class ProfilesController : BaseApiController
  {
      [HttpPost("add-photo")]
      public async Task<ActionResult<Photo>> AddPhoto([FromForm] IFormFile file)
      {
          return HandleResult(await Mediator.Send(new AddPhoto.Command { File = file }));
      }

      [HttpGet("{userId}/photos")]
      public async Task<ActionResult<List<Photo>>> GetPhotosForUser(string userId)
      {
          return HandleResult(await Mediator.Send(new GetProfilePhotos.Query { UserId = userId }));
      }

      [HttpDelete("{photoId}/photos")]
      public async Task<ActionResult> DeletePhoto(string photoId)
      {
          return HandleResult(await Mediator.Send(new DeletePhoto.Command { PhotoId = photoId }));
      }

      [HttpPut("{photoId}/set-main")]
      public async Task<ActionResult> SetMainPhoto(string photoId)
      {
          return HandleResult(await Mediator.Send(new SetMainPhoto.Command { PhotoId = photoId }));
      }

      [HttpGet("{userId}")]
      public async Task<ActionResult<UserProfile>> GetProfile(string userId)
      {
          return HandleResult(await Mediator.Send(new GetProfile.Query { UserId = userId }));
      }
  }
  ```

### Key Idea
The `ProfilesController` provides RESTful endpoints for photo and profile management, using `[FromForm]` for file uploads and handling results consistently.

## Key Commands Recap
- **Install Cloudinary Package**: `dotnet add package CloudinaryDotNet`
- **Create Migration**: `dotnet ef migrations add PhotoEntityAdded -p Persistence -s API`
- **Remove Migration (if needed)**: `dotnet ef migrations remove -p Persistence -s API`
- **Run API**: `dotnet watch`
- **Test Endpoints in Postman**:
  - `POST /api/profiles/add-photo`: Upload as form-data with key `file`.
  - `GET /api/profiles/{userId}/photos`: Retrieve user’s photos.
  - `DELETE /api/profiles/{photoId}/photos`: Delete a photo.
  - `PUT /api/profiles/{photoId}/set-main`: Set main photo.
  - `GET /api/profiles/{userId}`: Get user profile.

## Tips for Beginners
- **Avoid Typos in Configuration**: Double-check `CloudinarySettings` keys in `appsettings.json` and `Program.cs` to prevent runtime errors.
- **Handle JSON Serialization Issues**: Use `[JsonIgnore]` for navigation properties to avoid circular reference errors.
- **Test File Uploads**: Use small images in Postman to avoid delays and verify uploads in Cloudinary.
- **Understand Cascade Delete**: Decide whether to use cascade delete for photos based on application needs to avoid orphaned data in Cloudinary.
- **Use Postman for Testing**: Ensure correct user IDs and form-data keys when testing endpoints.

## Next Steps
- Implement client-side photo upload functionality with a cropper for square aspect ratios.
- Enhance profile pages to display and manage uploaded photos.
- Consider periodic cleanup for orphaned photos in Cloudinary if not using cascade delete.