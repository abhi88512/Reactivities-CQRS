# Section 10: Error Handling and Validation in .NET and React

## Introduction to Error Handling and Validation

### Definition
Error handling involves managing and responding to unexpected issues in an application, while validation ensures that incoming data meets specific criteria before being processed.

### Purpose
Proper error handling and validation improve user experience by providing clear feedback and prevent application crashes or incorrect data storage, ensuring reliability and security.

### Key Idea
Centralize error handling and validation to maintain clean architecture and consistent responses across both server and client.

> **Analogy**: Think of error handling and validation as a bouncer at a club. The bouncer (validation) checks IDs to ensure only valid guests (data) enter, while security (error handling) deals with any disruptions calmly, guiding troublemakers (errors) out without causing a scene.

## Learning Goals
- **Understand Validation**: Learn to validate data at multiple levels (DTO, domain, database) to ensure data integrity.
- **Handle HTTP Errors**: Implement proper HTTP error responses (e.g., 400, 404, 500) in the API.
- **Centralize Exception Handling**: Use custom middleware in .NET to manage exceptions consistently.
- **Use Axios Interceptors**: Centralize client-side error handling in React using Axios interceptors.
- **Apply Clean Architecture**: Ensure the application layer remains independent of presentation technology (API or console).

## Validation in .NET

### Data Annotations
- **Definition**: Data annotations are attributes in .NET used to enforce validation rules on data transfer objects (DTOs).
- **Example**: Using `[Required]` to ensure a field like `Title` is not empty.
- **Implementation**:
  - Create a `CreateActivityDto` class in the `Application/Activities/Dtos` folder to receive client data.
  - Apply annotations like `[Required]` to properties.

```csharp
public class CreateActivityDto
{
    [Required(ErrorMessage = "Title is required")]
    public string Title { get; set; } = string.Empty;
    [Required(ErrorMessage = "Description is required")]
    public string Description { get; set; } = string.Empty;
    // Other properties with similar annotations
}
```

- **Outcome**: When an empty object is sent, the API returns a 400 Bad Request with specific validation errors, but this relies on the API controller, which may not align with clean architecture.

### Fluent Validation
- **Definition**: A .NET library for defining complex validation rules in a fluent, programmatic way, integrated into the application layer.
- **Purpose**: Moves validation logic from the API layer to the application layer, adhering to clean architecture principles.
- **Implementation**:
  - Install `FluentValidation.DependencyInjectionExtensions` via NuGet in the application project.
  - Create a validator class, e.g., `CreateActivityValidator`, in `Application/Activities/Validators`.
  - Define rules for properties using a fluent syntax.

```csharp
public class CreateActivityValidator : AbstractValidator<CreateActivityCommand>
{
    public CreateActivityValidator()
    {
        RuleFor(x => x.ActivityDto.Title)
            .NotEmpty().WithMessage("Title is required")
            .MaximumLength(100).WithMessage("Title must not exceed 100 characters");
        RuleFor(x => x.ActivityDto.Date)
            .NotEmpty().WithMessage("Date is required")
            .GreaterThan(DateTime.UtcNow).WithMessage("Date must be in the future");
        // Additional rules for other properties
    }
}
```

- **Integration**:
  - Register validators in `Program.cs`:

```csharp
builder.Services.AddValidatorsFromAssemblyContaining<CreateActivityValidator>();
```

  - Use mediator middleware to automatically validate commands.

### Mediator Middleware for Validation
- **Definition**: Custom middleware in the mediator pipeline to handle validation automatically, reducing handler complexity.
- **Implementation**:
  - Create a `ValidationBehavior` class in `Application/Core` to validate requests.

```csharp
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    private readonly IValidator<TRequest>? _validator;
    public ValidationBehavior(IValidator<TRequest>? validator = null)
    {
        _validator = validator;
    }
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        if (_validator == null) return await next();
        var validationResult = await _validator.ValidateAsync(request, cancellationToken);
        if (!validationResult.IsValid)
            throw new ValidationException(validationResult.Errors);
        return await next();
    }
}
```

  - Register in `Program.cs`:

```csharp
builder.Services.AddMediator(x =>
{
    x.RegisterServicesFromAssembly(typeof(Program).Assembly);
    x.AddOpenBehavior(typeof(ValidationBehavior<,>));
});
```

- **Outcome**: Validation occurs before the handler processes the request, throwing a `ValidationException` if rules are violated.

## Exception Handling in .NET

### Custom Exception Middleware
- **Definition**: Middleware in the API layer to catch and format exceptions as HTTP responses, ensuring consistent error handling.
- **Implementation**:
  - Create an `ExceptionMiddleware` class in `API/Middleware`.

```csharp
public class ExceptionMiddleware : IMiddleware
{
    private readonly ILogger<ExceptionMiddleware> _logger;
    private readonly IHostEnvironment _env;
    public ExceptionMiddleware(ILogger<ExceptionMiddleware> logger, IHostEnvironment env)
    {
        _logger = logger;
        _env = env;
    }
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        try
        {
            await next(context);
        }
        catch (ValidationException ex)
        {
            await HandleValidationException(context, ex);
        }
        catch (Exception ex)
        {
            await HandleException(context, ex);
        }
    }
    private async Task HandleValidationException(HttpContext context, ValidationException ex)
    {
        var validationErrors = new Dictionary<string, string[]>();
        if (ex.Errors != null)
        {
            foreach (var error in ex.Errors)
            {
                if (validationErrors.TryGetValue(error.PropertyName, out var existingErrors))
                    validationErrors[error.PropertyName] = [..existingErrors, error.ErrorMessage];
                else
                    validationErrors[error.PropertyName] = [error.ErrorMessage];
            }
        }
        context.Response.StatusCode = StatusCodes.Status400BadRequest;
        var problemDetails = new ValidationProblemDetails(validationErrors)
        {
            Status = StatusCodes.Status400BadRequest,
            Type = "ValidationFailure",
            Title = "Validation Error",
            Detail = "One or more validation errors occurred"
        };
        await context.Response.WriteAsJsonAsync(problemDetails);
    }
    private async Task HandleException(HttpContext context, Exception ex)
    {
        _logger.LogError(ex, ex.Message);
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = StatusCodes.Status500InternalServerError;
        var response = _env.IsDevelopment()
            ? new AppException(context.Response.StatusCode, ex.Message, ex.StackTrace)
            : new AppException(context.Response.StatusCode, ex.Message, null);
        var options = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
        var json = JsonSerializer.Serialize(response, options);
        await context.Response.WriteAsync(json);
    }
}
```

  - Define an `AppException` class in `Application/Core` to structure exception responses.

```csharp
public class AppException(int statusCode, string message, string? details = null)
{
    public int StatusCode { get; set; } = statusCode;
    public string Message { get; set; } = message;
    public string? Details { get; set; } = details;
}
```

  - Register in `Program.cs`:

```csharp
builder.Services.AddTransient<ExceptionMiddleware>();
app.UseMiddleware<ExceptionMiddleware>();
```

- **Outcome**: Exceptions are caught and returned as JSON-formatted HTTP responses (e.g., 400 for validation errors, 500 for server errors).

### Result Object for Handler Responses
- **Definition**: A generic `Result<T>` class to encapsulate success or failure responses from mediator handlers, avoiding direct HTTP responses in the application layer.
- **Implementation**:
  - Create a `Result<T>` class in `Application/Core`.

```csharp
public class Result<T>
{
    public bool IsSuccess { get; set; }
    public T? Value { get; set; }
    public string? Error { get; set; }
    public int Code { get; set; }
    public static Result<T> Success(T value) => new() { IsSuccess = true, Value = value };
    public static Result<T> Failure(string error, int code) => new() { IsSuccess = false, Error = error, Code = code };
}
```

  - Update handlers to return `Result<T>` instead of raw objects. Example for `GetActivityDetails`:

```csharp
public class Details : IRequestHandler<Query, Result<Activity>>
{
    public async Task<Result<Activity>> Handle(Query request, CancellationToken cancellationToken)
    {
        var activity = await _context.Activities.FindAsync(request.Id);
        return activity == null 
            ? Result<Activity>.Failure("Activity not found", 404) 
            : Result<Activity>.Success(activity);
    }
}
```

  - Handle results in `BaseApiController`:

```csharp
public class BaseApiController : ControllerBase
{
    protected ActionResult HandleResult<T>(Result<T> result)
    {
        if (!result.IsSuccess && result.Code == 404) return NotFound();
        if (result.IsSuccess && result.Value != null) return Ok(result.Value);
        return BadRequest(result.Error);
    }
}
```

- **Outcome**: Handlers return a `Result<T>` object, and the API controller maps it to appropriate HTTP responses (e.g., 404 for not found, 200 for success).

## Client-Side Error Handling in React

### Axios Interceptors
- **Definition**: Axios interceptors in the React client centralize error handling for HTTP responses, updating the UI based on error types.
- **Implementation**:
  - Update `agent.ts` to handle errors in the response interceptor.

```typescript
axios.interceptors.response.use(
  async (response) => {
    await sleep(1000); // Simulate delay
    store.uiStore.setIsIdle();
    return response;
  },
  async (error) => {
    await sleep(1000); // Simulate delay
    store.uiStore.setIsIdle();
    const { status, data } = error.response;
    switch (status) {
      case 400:
        if (data.errors) {
          const modelStateErrors = [];
          for (const key in data.errors) {
            if (data.errors[key]) modelStateErrors.push(...data.errors[key]);
          }
          throw modelStateErrors.flat();
        } else {
          toast.error(data);
        }
        break;
      case 401:
        toast.error("Unauthorized");
        break;
      case 404:
        router.navigate("/not-found");
        break;
      case 500:
        router.navigate("/server-error", { state: { error: data } });
        break;
    }
    return Promise.reject(error);
  }
);
```

- **Outcome**: Errors are caught and handled appropriately (e.g., toasts for 401, redirects for 404/500, validation errors thrown for forms).

### Not Found Component
- **Definition**: A React component to display when a 404 Not Found response is received.
- **Implementation**:
  - Create `NotFound.tsx` in `client/src/features/errors`.

```typescript
import { Button, Paper, Typography } from '@mui/material';
import { SearchOff } from '@mui/icons-material';
import { Link } from 'react-router-dom';

export default function NotFound() {
  return (
    <Paper sx={{ height: 400, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', p: 6 }}>
      <SearchOff sx={{ fontSize: 100, color: 'primary.main' }} />
      <Typography gutterBottom variant="h3">
        Oops, we could not find what you are looking for!
      </Typography>
      <Button fullWidth component={Link} to="/activities">
        Return to the activities page
      </Button>
    </Paper>
  );
}
```

  - Add route in `routes.tsx`:

```typescript
{ path: 'not-found', element: <NotFound /> },
{ path: '*', element: <Navigate replace to="/not-found" /> }
```

- **Outcome**: Users are redirected to a user-friendly not found page for 404 errors.

### Server Error Component
- **Definition**: A React component to display server error details, particularly useful in development mode.
- **Implementation**:
  - Create `ServerError.tsx` in `client/src/features/errors`.

```typescript
import { Paper, Typography, Divider } from '@mui/material';
import { useLocation } from 'react-router-dom';

export default function ServerError() {
  const { state } = useLocation();
  return (
    <Paper>
      {state?.error ? (
        <>
          <Typography gutterBottom variant="h3" color="secondary" sx={{ px: 4, pt: 2 }}>
            {state.error.message ?? 'There has been an error'}
          </Typography>
          <Divider />
          <Typography variant="body1" sx={{ p: 4 }}>
            {state.error.details ?? 'Internal server error'}
          </Typography>
        </>
      ) : (
        <Typography variant="h5">Server error</Typography>
      )}
    </Paper>
  );
}
```

  - Add route in `routes.tsx`:

```typescript
{ path: 'server-error', element: <ServerError /> }
```

- **Outcome**: Displays error message and stack trace (in development) for 500 errors, aiding debugging.

### Validation Errors in Forms
- **Definition**: Displaying validation errors in the UI, typically in forms, using data from the API.
- **Implementation**:
  - Update `TestErrors.tsx` to display validation errors.

```typescript
import { useState } from 'react';
import { useMutation } from '@tanstack/react-query';
import { Typography, Button, Alert } from '@mui/material';
import agent from '../../api/agent';

export default function TestErrors() {
  const [validationErrors, setValidationErrors] = useState<string[]>([]);
  const { mutate } = useMutation({
    mutationFn: ({ path, method }: { path: string; method: string }) =>
      method === 'post' ? agent.post(path, {}) : agent.get(path),
    onError: (error) => {
      if (Array.isArray(error)) setValidationErrors(error);
      else setValidationErrors([]);
    }
  });
  const handleError = (path: string, method: string) => mutate({ path, method });

  return (
    <>
      <Typography>Test Errors Component</Typography>
      <Button onClick={() => handleError('/api/buggy/bad-request', 'get')}>Bad Request</Button>
      <Button onClick={() => handleError('/api/buggy/not-found', 'get')}>Not Found</Button>
      <Button onClick={() => handleError('/api/activities', 'post')}>Validation Error</Button>
      <Button onClick={() => handleError('/api/buggy/server-error', 'get')}>Server Error</Button>
      <Button onClick={() => handleError('/api/buggy/unauthorized', 'get')}>Unauthorized</Button>
      {validationErrors.map((err, i) => (
        <Alert key={i} severity="error">{err}</Alert>
      ))}
    </>
  );
}
```

- **Outcome**: Validation errors are displayed as alerts, improving user feedback.

### Toast Notifications
- **Definition**: Use `react-toastify` to display non-intrusive error notifications.
- **Implementation**:
  - Install: `npm install react-toastify`
  - Add CSS and `ToastContainer` in `main.tsx`:

```typescript
import 'react-toastify/dist/react-toastify.css';
import { ToastContainer } from 'react-toastify';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
    <ToastContainer position="bottom-right" hideProgressBar theme="colored" />
  </React.StrictMode>
);
```

- **Outcome**: Errors like 400 (bad request) and 401 (unauthorized) display toasts, enhancing UX.

## Key Commands Recap
- **NuGet Install**: `dotnet add package FluentValidation.DependencyInjectionExtensions` - Adds FluentValidation to the application layer.
- **Restart API**: `dotnet watch` - Ensures changes are applied, as hot reload may fail.
- **NPM Install**: `npm install react-toastify` - Installs toast library for client-side notifications.

## Tips for Beginners
- **Start with Data Annotations**: Theyâ€™re simpler but less flexible than FluentValidation. Use for quick prototypes.
- **Restart API Frequently**: Hot reload in .NET can be unreliable; restarting ensures changes take effect.
- **Check Chrome DevTools**: Use the Network and Console tabs to debug API responses and client-side errors.
- **Keep Controllers Dumb**: Move logic to the application layer to maintain clean architecture.
- **Test Incrementally**: Validate each change (e.g., middleware, handlers) before moving to the next.

## Summary
This section introduced error handling and validation in a .NET and React application, emphasizing clean architecture. On the server side, we implemented validation using data annotations and FluentValidation, centralized exception handling with custom middleware, and used a `Result<T>` object to manage handler responses. On the client side, we centralized error handling with Axios interceptors, displayed user-friendly error pages for 404 and 500 errors, and showed validation errors and toasts for other errors. These practices ensure a robust, user-friendly application that handles errors gracefully while adhering to clean architecture principles.