# Section 21: Implementing Infinite Scrolling and Filtering

## Introduction to Infinite Scrolling and Filtering

### Definition
Infinite scrolling allows users to load additional data (e.g., activities) automatically as they scroll down a page, while filtering enables users to refine the displayed data based on specific criteria (e.g., events they are attending or hosting).

### Purpose
These features enhance the user experience by providing seamless data loading without manual button clicks and allowing users to view relevant activities based on selected filters, improving navigation and interaction.

### Key Idea
Infinite scrolling uses cursor-based pagination to fetch batches of data, and filtering refines the data retrieved from the API based on user-defined parameters.

> **Analogy**: Infinite scrolling is like reading a book where new pages appear as you reach the end, without needing to turn a page manually. Filtering is like choosing to read only chapters written by a specific author.

## Learning Goals
- **Implement Cursor-Based Pagination**: Use a `PagedList` to return batches of activities with a cursor for the next page.
- **Enable Infinite Scrolling**: Configure the React client to load more activities as the user scrolls.
- **Add Filtering**: Allow users to filter activities by criteria such as attendance, hosting, or date.
- **Improve UI**: Fix the navbar, make filters sticky, and use subtle loading indicators for a better user experience.

## Cursor-Based Pagination

### Definition
Cursor-based pagination retrieves data in batches using a cursor (e.g., a `DateTime` value) to mark the starting point for the next batch, improving performance by leveraging database indexes.

### Implementation
- **PagedList Class**: A generic class to return paginated data with a cursor.
- **Index on Date**: Add an index to the `Date` property in the `Activity` entity for efficient queries.

### Code Example (PagedList Class)
```csharp
public class PagedList<T, TCursor>
{
    public List<T> Items { get; set; }
    public TCursor? NextCursor { get; set; }

    public PagedList(List<T> items, TCursor? nextCursor)
    {
        Items = items;
        NextCursor = nextCursor;
    }
}
```

### Code Example (Activity Entity Index)
```csharp
[Index(nameof(Date))]
public class Activity
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Title { get; set; } = null!;
    public DateTime Date { get; set; }
    // Other properties...
}
```

### Code Example (GetActivities Handler)
```csharp
public class GetActivities
{
    private const int MaxPageSize = 50;

    public class Query : IRequest<Result<PagedList<ActivityDto, DateTime?>>>
    {
        public required ActivityParams Params { get; set; }
    }

    public class Handler : IRequestHandler<Query, Result<PagedList<ActivityDto, DateTime?>>>
    {
        private readonly AppDbContext _context;
        private readonly IMapper _mapper;
        private readonly IUserAccessor _userAccessor;

        public Handler(AppDbContext context, IMapper mapper, IUserAccessor userAccessor)
        {
            _context = context;
            _mapper = mapper;
            _userAccessor = userAccessor;
        }

        public async Task<Result<PagedList<ActivityDto, DateTime?>>> Handle(Query request, CancellationToken cancellationToken)
        {
            var query = _context.Activities
                .OrderBy(x => x.Date)
                .Where(x => x.Date >= (request.Params.Cursor ?? request.Params.StartDate))
                .AsQueryable();

            if (!string.IsNullOrEmpty(request.Params.Filter))
            {
                query = request.Params.Filter switch
                {
                    "isGoing" => query.Where(x => x.Attendees.Any(a => a.UserId == _userAccessor.GetUserId())),
                    "isHost" => query.Where(x => x.Attendees.Any(a => a.IsHost && a.UserId == _userAccessor.GetUserId())),
                    _ => query
                };
            }

            var activities = await query
                .ProjectTo<ActivityDto>(_mapper.ConfigurationProvider, new { currentUserId = _userAccessor.GetUserId() })
                .Take(request.Params.PageSize + 1)
                .ToListAsync(cancellationToken);

            DateTime? nextCursor = null;
            if (activities.Count > request.Params.PageSize)
            {
                nextCursor = activities.Last().Date;
                activities.RemoveAt(activities.Count - 1);
            }

            return Result<PagedList<ActivityDto, DateTime?>>.Success(
                new PagedList<ActivityDto, DateTime?>(activities, nextCursor)
            );
        }
    }
}
```

### Code Example (PaginationParams and ActivityParams)
```csharp
public class PaginationParams<TCursor>
{
    private const int MaxPageSize = 50;
    private int _pageSize = 3;
    public int PageSize
    {
        get => _pageSize;
        set => _pageSize = value > MaxPageSize ? MaxPageSize : value;
    }
    public TCursor? Cursor { get; set; }
}

public class ActivityParams : PaginationParams<DateTime?>
{
    public string? Filter { get; set; }
    public DateTime StartDate { get; set; } = DateTime.UtcNow;
}
```

### Create Migration
```bash
dotnet ef migrations add DateIndexAdded -p Persistence -s API
```

## Client-Side Implementation (React)

### Update Type Definitions
- Define a `PagedList` type to match the server-side response.
```typescript
export type PagedList<T, TCursor> = {
    items: T[];
    nextCursor: TCursor;
};
```

### Update UseActivities Hook
- Use `useInfiniteQuery` from React Query to handle pagination.
- Integrate MobX for filter persistence.
```typescript
import { useInfiniteQuery } from "@tanstack/react-query";
import { useStore } from "../stores/store";
import { agent } from "../lib/api";
import { Activity } from "./types";

export const useActivities = () => {
    const { activityStore: { filter, startDate } } = useStore();

    const { data: activitiesGroup, isFetchingNextPage, fetchNextPage, hasNextPage } = useInfiniteQuery({
        queryKey: ["activities", filter, startDate],
        queryFn: async ({ pageParam = null }) => {
            const response = await agent.get<PagedList<Activity, string>>(
                `/activities?filter=${filter}&startDate=${startDate}&cursor=${pageParam}&pageSize=3`
            );
            return response.data;
        },
        initialPageParam: null,
        getNextPageParam: (lastPage) => lastPage.nextCursor,
        select: (data) => ({
            ...data,
            pages: data.pages.map((page) => ({
                ...page,
                items: page.items.map((activity) => ({
                    ...activity,
                    date: new Date(activity.date),
                })),
            })),
        }),
        placeholderData: keepPreviousData,
        staleTime: 1000 * 60 * 5, // 5 minutes
    });

    return { activitiesGroup, isFetchingNextPage, fetchNextPage, hasNextPage };
};
```

### Activity Store (MobX)
- Store filter and start date globally to persist user selections.
```typescript
import { makeAutoObservable } from "mobx";

export class ActivityStore {
    filter: string = "all";
    startDate: string = new Date().toISOString();

    constructor() {
        makeAutoObservable(this);
    }

    setFilter = (filter: string) => {
        this.filter = filter;
    };

    setStartDate = (date: Date) => {
        this.startDate = date.toISOString();
    };
}
```

### Update Store
```typescript
export class Store {
    activityStore: ActivityStore;

    constructor() {
        this.activityStore = new ActivityStore();
    }
}
```

### Activity List Component
- Use `useInView` from `react-intersection-observer` for infinite scrolling.
- Make the component an observer to react to MobX state changes.
```typescript
import { Box, Fragment } from "@mui/material";
import { observer } from "mobx-react-lite";
import { useInView } from "react-intersection-observer";
import { useActivities } from "../../lib/hooks/useActivities";
import ActivityCard from "./ActivityCard";

const ActivityList = observer(() => {
    const { activitiesGroup, isFetchingNextPage, fetchNextPage, hasNextPage } = useActivities();
    const { ref, inView } = useInView({ threshold: 0.5 });

    useEffect(() => {
        if (inView && hasNextPage) {
            fetchNextPage();
        }
    }, [inView, hasNextPage, fetchNextPage]);

    if (!activitiesGroup) return null;

    return (
        <Box>
            {activitiesGroup.pages.map((activities, index) => (
                <Box
                    key={index}
                    ref={index === activitiesGroup.pages.length - 1 ? ref : null}
                    display="flex"
                    flexDirection="column"
                    gap={3}
                >
                    {activities.items.map((activity) => (
                        <ActivityCard key={activity.id} activity={activity} />
                    ))}
                </Box>
            ))}
        </Box>
    );
});

export default ActivityList;
```

### Activity Filters Component
- Update filters to use MobX store and make the component an observer.
```typescript
import { Box, MenuItem, Calendar } from "@mui/material";
import { observer } from "mobx-react-lite";
import { useStore } from "../../lib/hooks/useStore";

const ActivityFilters = observer(() => {
    const { activityStore: { filter, startDate, setFilter, setStartDate } } = useStore();

    return (
        <Box>
            <MenuItem selected={filter === "all"} onClick={() => setFilter("all")}>
                All Events
            </MenuItem>
            <MenuItem selected={filter === "isGoing"} onClick={() => setFilter("isGoing")}>
                I'm Going
            </MenuItem>
            <MenuItem selected={filter === "isHost"} onClick={() => setFilter("isHost")}>
                I'm Hosting
            </MenuItem>
            <Calendar value={new Date(startDate)} onChange={(date) => setStartDate(date as Date)} />
        </Box>
    );
});

export default ActivityFilters;
```

### Navbar Improvements
- Fix the navbar to the top and add a subtle loading spinner.
```typescript
import { AppBar, Typography, CircularProgress } from "@mui/material";
import { observer } from "mobx-react-lite";
import { useStore } from "../lib/hooks/useStore";

const Navbar = observer(() => {
    const { loading } = useStore();

    return (
        <AppBar position="fixed">
            <Typography position="relative">
                Reactivities
                {loading && (
                    <CircularProgress
                        size={20}
                        thickness={7}
                        sx={{ color: "white", position: "absolute", top: "30%", left: "105%" }}
                    />
                )}
            </Typography>
        </AppBar>
    );
});

export default Navbar;
```

### App.tsx Adjustment
- Add padding to prevent content overlap with the fixed navbar.
```typescript
import { Container } from "@mui/material";

export default function App() {
    return (
        <Container sx={{ pt: 14 }}>
            {/* App content */}
        </Container>
    );
}
```

### Activity Dashboard Styling
- Make filters sticky.
```typescript
import { Grid } from "@mui/material";

export default function ActivityDashboard() {
    return (
        <Grid container spacing={2}>
            <Grid item xs={8}>
                {/* Activity List */}
            </Grid>
            <Grid item xs={4} sx={{ position: "sticky", top: 112, alignSelf: "flex-start" }}>
                {/* Activity Filters */}
            </Grid>
        </Grid>
    );
}
```

### Install Intersection Observer
```bash
npm install react-intersection-observer
```

## Key Commands Recap
- **Create Migration**:
  ```bash
  dotnet ef migrations add DateIndexAdded -p Persistence -s API
  ```
- **Install Intersection Observer**:
  ```bash
  npm install react-intersection-observer
  ```

## Tips for Beginners
- **Cursor-Based Pagination**: Use a database index on the cursor field (e.g., `Date`) to optimize query performance.
- **MobX and React Query**: Combine MobX for state persistence (e.g., filters) with React Query for data fetching to maintain UI consistency.
- **TypeScript Warnings**: Address TypeScript issues promptly, especially with complex types like `PagedList`, to avoid runtime errors.
- **Subtle Loading**: Replace full-screen loading indicators with smaller spinners to improve UX, especially for fast APIs.
- **Observer Components**: Ensure components using MobX stores are wrapped with `observer` to react to state changes.

## Next Steps
- Test infinite scrolling by scrolling through activities and verifying new batches load seamlessly.
- Test filters (e.g., "I'm Going", "I'm Hosting", date selection) to ensure correct activities are displayed.
- Consider adding a placeholder message for empty activity lists.
- Commit changes to source control to save progress.