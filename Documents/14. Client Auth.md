# Section 13: Client-Side Login and Registration

## Overview of Client-Side Authentication

### Definition
Client-side authentication in this context involves creating React components and hooks to handle user login, registration, and navigation, integrating with the ASP.NET Core Identity API endpoints while managing user state and protecting routes.

### Purpose
This section focuses on building a user-friendly interface for users to log in or register, handling server-side validation errors, and implementing private routes to enhance the user experience by preventing unauthorized access to protected pages.

### Key Idea
Client-side authentication enhances user experience by providing intuitive login/registration forms and redirecting unauthenticated users to appropriate pages while maintaining secure server-side validation.

> **Analogy**: Think of client-side authentication as the front desk of a secure building. It guides users through the process of signing in or registering, but the actual security checks (like verifying credentials) happen at the server’s “security office.”

## Learning Goals
- **Create Login and Registration Forms**: Build React forms for user authentication using React Hook Form and Zod for validation.
- **Handle Server-Side Validation Errors**: Display API validation errors (e.g., duplicate email) in the client-side form.
- **Implement Private Routes**: Prevent unauthenticated users from accessing protected pages using React Router.
- **Manage User State**: Use React Query to fetch and maintain the current user’s information after login.
- **Enhance User Experience**: Add a user menu and redirect users appropriately after login/logout.

## Setting Up Client-Side Authentication

### User Account Hook
- The `useAccount` hook manages login, logout, registration, and fetching the current user’s information using React Query.

```tsx
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { useNavigate, useLocation } from 'react-router-dom';
import { toast } from 'react-toastify';
import { agent } from '../utils/agent';
import { LoginSchema } from '../schemas/loginSchema';
import { RegisterSchema } from '../schemas/registerSchema';

interface User {
  id: string;
  email: string;
  displayName: string;
  imageUrl?: string;
}

export const useAccount = () => {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const location = useLocation();

  const { data: currentUser, isLoading: loadingUserInfo } = useQuery<User>({
    queryKey: ['user'],
    queryFn: async () => {
      const response = await agent.get('/account/user-info');
      return response.data;
    },
    enabled: !queryClient.getQueryData(['user']) && 
            location.pathname !== '/login' && 
            location.pathname !== '/register',
  });

  const loginUser = useMutation({
    mutationFn: async (creds: LoginSchema) => {
      await agent.post('/login', creds);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ['user'] });
    },
  });

  const registerUser = useMutation({
    mutationFn: async (creds: RegisterSchema) => {
      await agent.post('/account/register', creds);
    },
    onSuccess: () => {
      toast.success('Registration successful. You can now log in.');
      navigate('/login');
    },
  });

  const logoutUser = useMutation({
    mutationFn: async () => {
      await agent.post('/account/logout');
    },
    onSuccess: () => {
      queryClient.removeQueries({ queryKey: ['user'] });
      queryClient.removeQueries({ queryKey: ['activities'] });
      navigate('/');
    },
  });

  return { currentUser, loginUser, registerUser, logoutUser, loadingUserInfo };
};
```

- **Key Features**:
  - Fetches the current user with a query that only runs if no user data is cached and the user is not on the login/register pages.
  - Handles login, registration, and logout with mutations.
  - Invalidates or removes queries to keep client state in sync with the server.

### Login Form
- Uses React Hook Form and Zod for client-side validation.

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { Box, Button, TextField, Typography } from '@mui/material';
import { loginSchema, LoginSchema } from '../schemas/loginSchema';
import { useAccount } from '../hooks/useAccount';

export const LoginForm = () => {
  const { loginUser } = useAccount();
  const navigate = useNavigate();
  const location = useLocation();

  const { register, handleSubmit, formState: { errors } } = useForm<LoginSchema>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginSchema) => {
    await loginUser.mutateAsync(data, {
      onSuccess: () => {
        navigate(location.state?.from || '/activities');
      },
    });
  };

  return (
    <Box component="form" onSubmit={handleSubmit(onSubmit)} sx={{ maxWidth: 400, mx: 'auto', mt: 4 }}>
      <TextField
        label="Email"
        {...register('email')}
        error={!!errors.email}
        helperText={errors.email?.message}
        fullWidth
        margin="normal"
      />
      <TextField
        label="Password"
        type="password"
        {...register('password')}
        error={!!errors.password}
        helperText={errors.password?.message}
        fullWidth
        margin="normal"
      />
      <Button type="submit" variant="contained" fullWidth sx={{ mt: 2 }}>
        Sign In
      </Button>
      <Typography textAlign="center" sx={{ mt: 2 }}>
        Don't have an account?{' '}
        <Typography component={Link} to="/register" color="primary" sx={{ ml: 2 }}>
          Sign Up
        </Typography>
      </Typography>
    </Box>
  );
};
```

- **Key Features**:
  - Validates email and password using `loginSchema`.
  - Redirects to the original destination (from `location.state.from`) or `/activities` after successful login.
  - Includes a link to the registration page.

### Register Form
- Similar to the login form but includes a `displayName` field and handles server-side validation errors.

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Link } from 'react-router-dom';
import { Box, Button, TextField, Typography } from '@mui/material';
import { RegisterSchema, registerSchema } from '../schemas/registerSchema';
import { useAccount } from '../hooks/useAccount';

export const RegisterForm = () => {
  const { registerUser } = useAccount();
  const { register, handleSubmit, setError, formState: { errors } } = useForm<RegisterSchema>({
    resolver: zodResolver(registerSchema),
  });

  const onSubmit = async (data: RegisterSchema) => {
    await registerUser.mutateAsync(data, {
      onError: (error: any) => {
        if (Array.isArray(error)) {
          error.forEach((err: string) => {
            if (err.includes('email')) {
              setError('email', { message: err });
            } else if (err.includes('password')) {
              setError('password', { message: err });
            }
          });
        }
      },
    });
  };

  return (
    <Box component="form" onSubmit={handleSubmit(onSubmit)} sx={{ maxWidth: 400, mx: 'auto', mt: 4 }}>
      <TextField
        label="Display Name"
        {...register('displayName')}
        error={!!errors.displayName}
        helperText={errors.displayName?.message}
        fullWidth
        margin="normal"
      />
      <TextField
        label="Email"
        {...register('email')}
        error={!!errors.email}
        helperText={errors.email?.message}
        fullWidth
        margin="normal"
      />
      <TextField
        label="Password"
        type="password"
        {...register('password')}
        error={!!errors.password}
        helperText={errors.password?.message}
        fullWidth
        margin="normal"
      />
      <Button type="submit" variant="contained" fullWidth sx={{ mt: 2 }}>
        Register
      </Button>
      <Typography textAlign="center" sx={{ mt: 2 }}>
        Already have an account?{' '}
        <Typography component={Link} to="/login" color="primary" sx={{ ml: 2 }}>
          Sign In
        </Typography>
      </Typography>
    </Box>
  );
};
```

- **Key Features**:
  - Validates `displayName`, `email`, and `password` using `registerSchema`.
  - Handles server-side errors (e.g., duplicate email, weak password) by mapping them to form fields using `setError`.
  - Redirects to the login page with a success toast after registration.

### Register Schema
- Defines validation rules using Zod, leaving password complexity to the server.

```ts
import { z } from 'zod';
import { requiredString } from '../utils/util';

export const registerSchema = z.object({
  displayName: requiredString('displayName'),
  email: z.string().email('Invalid email address'),
  password: requiredString('password'),
});

export type RegisterSchema = z.infer<typeof registerSchema>;
```

### User Menu
- Displays a dropdown menu for authenticated users with options like creating activities, viewing profiles, and logging out.

```tsx
import { useState } from 'react';
import { Button, Menu, MenuItem, ListItemIcon, ListItemText, Divider, Box, Avatar } from '@mui/material';
import { Link } from 'react-router-dom';
import { Add, Person, Logout } from '@mui/icons-material';
import { useAccount } from '../hooks/useAccount';

export const UserMenu = () => {
  const { currentUser, logoutUser } = useAccount();
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const open = Boolean(anchorEl);

  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  if (!currentUser) return null;

  return (
    <>
      <Button color="inherit" size="large" sx={{ fontSize: '1.1rem' }} onClick={handleClick}>
        <Box display="flex" alignItems="center" gap={2}>
          <Avatar />
          {currentUser.displayName}
        </Box>
      </Button>
      <Menu anchorEl={anchorEl} open={open} onClose={handleClose}>
        <MenuItem component={Link} to="/create-activity" onClick={handleClose}>
          <ListItemIcon><Add /></ListItemIcon>
          <ListItemText>Create Activity</ListItemText>
        </MenuItem>
        <MenuItem component={Link} to="/profile" onClick={handleClose}>
          <ListItemIcon><Person /></ListItemIcon>
          <ListItemText>My Profile</ListItemText>
        </MenuItem>
        <Divider />
        <MenuItem onClick={() => { logoutUser.mutate(); handleClose(); }}>
          <ListItemIcon><Logout /></ListItemIcon>
          <ListItemText>Logout</ListItemText>
        </MenuItem>
      </Menu>
    </>
  );
};
```

- **Key Features**:
  - Displays the user’s avatar and display name.
  - Provides links to create activities and view profiles, with a logout option that clears queries and redirects to the home page.

### Private Routes
- Prevents unauthenticated users from accessing protected routes using a `RequireAuth` component.

```tsx
import { Outlet, Navigate, useLocation } from 'react-router-dom';
import { Typography } from '@mui/material';
import { useAccount } from '../hooks/useAccount';

export const RequireAuth = () => {
  const { currentUser, loadingUserInfo } = useAccount();
  const location = useLocation();

  if (loadingUserInfo) {
    return <Typography>Loading...</Typography>;
  }

  if (!currentUser) {
    return <Navigate to="/login" state={{ from: location.pathname }} />;
  }

  return <Outlet />;
};
```

- **Key Features**:
  - Checks if the user is loading or unauthenticated.
  - Redirects unauthenticated users to the login page, preserving the original destination in `location.state.from`.
  - Renders child routes (`Outlet`) if authenticated.

### Routing Configuration
- Update `routes.tsx` to include protected routes within `RequireAuth`.

```tsx
import { createBrowserRouter } from 'react-router-dom';
import { LoginForm } from '../features/account/LoginForm';
import { RegisterForm } from '../features/account/RegisterForm';
import { ActivityDashboard } from '../features/activities/ActivityDashboard';
import { CreateActivity } from '../features/activities/CreateActivity';
import { RequireAuth } from './RequireAuth';

export const router = createBrowserRouter([
  {
    path: '/',
    element: <div>Home Page</div>,
  },
  {
    path: '/login',
    element: <LoginForm />,
  },
  {
    path: '/register',
    element: <RegisterForm />,
  },
  {
    element: <RequireAuth />,
    children: [
      {
        path: '/activities',
        element: <ActivityDashboard />,
      },
      {
        path: '/activities/:id',
        element: <div>Activity Details</div>,
      },
      {
        path: '/create-activity',
        element: <CreateActivity />,
      },
    ],
  },
]);
```

- **Key Features**:
  - Protected routes (`/activities`, `/activities/:id`, `/create-activity`) are nested under `RequireAuth`.
  - Unprotected routes (`/`, `/login`, `/register`) are accessible to all users.

### Conditional Queries in Activities Hook
- Prevent React Query from fetching activities when the user is unauthenticated.

```tsx
import { useQuery } from '@tanstack/react-query';
import { agent } from '../utils/agent';
import { useAccount } from './useAccount';

interface Activity {
  id: string;
  title: string;
  // Other properties
}

export const useActivities = () => {
  const { currentUser } = useAccount();

  const { data: activities, isLoading } = useQuery<Activity[]>({
    queryKey: ['activities'],
    queryFn: async () => {
      const response = await agent.get('/activities');
      return response.data;
    },
    enabled: !!currentUser,
  });

  const { data: activity } = useQuery<Activity>({
    queryKey: ['activities', 'id'],
    queryFn: async () => {
      const response = await agent.get('/activities/some-id');
      return response.data;
    },
    enabled: !!currentUser,
  });

  return { activities, activity, isLoading };
};
```

- **Key Features**:
  - Queries are disabled (`enabled: !!currentUser`) if no user is authenticated, preventing unauthorized API requests.

## Key Commands Recap
- **Start React App**:
  ```bash
  npm start
  ```
- **Install Dependencies** (if not already installed):
  ```bash
  npm install @tanstack/react-query react-router-dom @mui/material @emotion/react @emotion/styled react-toastify @hookform/resolvers zod
  ```

## Tips for Beginners
- **Client-Side vs. Server-Side Security**: Client-side routing (e.g., `RequireAuth`) is for user experience, not security. Always enforce security on the server (e.g., API authorization).
- **Use HTTP-Only Cookies**: Cookies are secure and inaccessible to JavaScript, preventing XSS attacks. Ensure `withCredentials` is set in Axios (`agent.ts`) for cookie-based authentication.
  ```ts
  const agent = axios.create({
    baseURL: 'http://localhost:5000/api',
    withCredentials: true,
  });
  ```
- **Handle Server Errors Gracefully**: Use React Query’s `onError` to map server-side validation errors to form fields for a seamless user experience.
- **Avoid Unnecessary Queries**: Use the `enabled` option in React Query to prevent queries when users are on login/register pages or unauthenticated.
- **Test Navigation**: Verify redirects work correctly by attempting to access protected routes without logging in and checking post-login redirects.

## Next Steps
- Test the login and registration flows in the browser, ensuring redirects and error handling work as expected.
- Enhance the user menu with additional features (e.g., profile editing).
- Consider adding client-side password complexity validation to match server requirements, reducing unnecessary API calls.
- Address any remaining UI issues, such as spacing or loading states, for a polished user experience.