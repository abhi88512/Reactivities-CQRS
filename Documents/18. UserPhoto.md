# Section 17: Implementing Client-Side Image Uploads

## Overview

### Definition
This section focuses on implementing client-side image upload functionality using React, React Dropzone, and React Cropper, enabling users to upload, crop, set as main, and delete profile photos, integrated with the API and Cloudinary.

### Purpose
To create a user-friendly interface for managing profile photos, including a profile page, drag-and-drop uploads, image cropping, and dynamic updates across components when the main photo changes.

### Key Idea
The client-side image upload feature allows users to manage their profile photos seamlessly, with real-time UI updates and integration with Cloudinary for storage, enhancing the user experience.

> **Analogy**: Think of the photo upload feature like a digital photo booth. Users can drop in a picture, adjust it to look just right, and display it on their profile, with changes instantly reflected everywhere, like updating a name tag at a party.

## Learning Goals
- **Create a Profile Page**: Build a profile page to display user details and photos, with tabs for different content sections.
- **Implement Photo Upload Widget**: Use React Dropzone for drag-and-drop uploads and React Cropper for image resizing and cropping.
- **Enable Photo Management**: Allow users to set a main photo and delete non-main photos, updating the UI dynamically.
- **Handle Memory Management**: Ensure proper cleanup of object URLs to prevent memory leaks.

## Setting Up User Images in Components

### Definition
Update existing components (e.g., `ActivityCard`, `UserMenu`) to display user profile images dynamically.

### Implementation
- **Update `Activity` Type in `Index.ts`**:
  ```typescript
  type Activity = {
    // Other properties...
    hostImageUrl: string;
  };
  ```
- **Update `useActivities` Hook**:
  ```typescript
  useQuery({
    queryKey: ['activities'],
    queryFn: fetchActivities,
    select: (data) => data.map(activity => {
      const host = activity.attendees.find(x => x.id === activity.hostId);
      return {
        ...activity,
        isHost: currentUser.id === activity.hostId,
        isGoing: activity.attendees.some(x => x.id === currentUser.id),
        hostImageUrl: host?.imageUrl
      };
    })
  });
  // Similar for individual activity query
  ```
- **Update `ActivityCard.tsx`**:
  ```jsx
  <Avatar
    src={activity.hostImageUrl}
    alt="Image of host"
  />
  ```
- **Update `UserMenu.tsx`**:
  ```jsx
  <Avatar
    src={currentUser.imageUrl}
    alt="Current user image"
  />
  ```

### Key Idea
Adding `hostImageUrl` to the `Activity` type and updating components ensures user images are displayed consistently across the application.

## Creating Profile Page

### Definition
Build a `ProfilePage` component to display user details and photos, with routes to access it.

### Implementation
- **Create `ProfilePage.tsx` in `features/profiles`**:
  ```jsx
  import { Grid2, Typography } from '@mui/material';
  import { useParams } from 'react-router-dom';
  import { useProfile } from '../../lib/hooks/useProfile';
  import ProfileHeader from './ProfileHeader';
  import ProfileContent from './ProfileContent';

  const ProfilePage = () => {
    const { id } = useParams();
    const { profile, loadingProfile } = useProfile(id);

    if (loadingProfile) return <Typography>Loading profile...</Typography>;
    if (!profile) return <Typography>Profile not found</Typography>;

    return (
      <Grid2 container>
        <Grid2 size={12}>
          <ProfileHeader profile={profile} />
          <ProfileContent profile={profile} />
        </Grid2>
      </Grid2>
    );
  };

  export default ProfilePage;
  ```
- **Update Routes in `routes.tsx`**:
  ```jsx
  <Route path="/profiles/:id" element={<ProfilePage />} />
  ```
- **Update `UserMenu.tsx` Link**:
  ```jsx
  <Link to={`/profiles/${currentUser.id}`}>My Profile</Link>
  ```

### Key Idea
The `ProfilePage` serves as a central hub for user profile management, accessible via routes and displaying dynamic content.

## Creating Profile Header

### Definition
Design a `ProfileHeader` component to display user details, such as avatar, display name, and follower stats.

### Implementation
- **In `features/profiles/ProfileHeader.tsx`**:
  ```jsx
  import { Avatar, Box, Button, Chip, Divider, Grid2, Stack, Typography } from '@mui/material';

  type Props = { profile: Profile };

  const ProfileHeader = ({ profile }: Props) => {
    const isFollowing = true; // Placeholder for future functionality
    return (
      <Paper elevation={3} sx={{ p: 4, borderRadius: 3 }}>
        <Grid2 container spacing={2}>
          <Grid2 size={8}>
            <Stack direction="row" spacing={3} alignItems="center">
              <Avatar
                src={profile.imageUrl}
                alt={`${profile.displayName} image`}
                sx={{ width: 150, height: 150 }}
              />
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                <Typography variant="h4">{profile.displayName}</Typography>
                {isFollowing && (
                  <Chip variant="outlined" color="secondary" label="Following" sx={{ borderRadius: 1 }} />
                )}
              </Box>
            </Stack>
          </Grid2>
          <Grid2 size={4}>
            <Stack spacing={2} alignItems="center">
              <Box sx={{ display: 'flex', justifyContent: 'space-around', width: '100%' }}>
                <Box sx={{ textAlign: 'center' }}>
                  <Typography variant="h6">Followers</Typography>
                  <Typography variant="h3">5</Typography>
                </Box>
                <Box sx={{ textAlign: 'center' }}>
                  <Typography variant="h6">Following</Typography>
                  <Typography variant="h3">42</Typography>
                </Box>
              </Box>
              <Divider sx={{ width: '100%' }} />
              <Button
                fullWidth
                variant="outlined"
                color={isFollowing ? 'error' : 'success'}
              >
                {isFollowing ? 'Unfollow' : 'Follow'}
              </Button>
            </Stack>
          </Grid2>
        </Grid2>
      </Paper>
    );
  };

  export default ProfileHeader;
  ```

### Key Idea
The `ProfileHeader` provides a visually appealing layout for user details, with placeholders for future follower functionality.

## Creating Profile Content with Tabs

### Definition
Implement a `ProfileContent` component with tabs to navigate between sections like About, Photos, Events, Followers, and Following.

### Implementation
- **In `features/profiles/ProfileContent.tsx`**:
  ```jsx
  import { Box, Tabs, Tab, Typography } from '@mui/material';
  import { useState, SyntheticEvent } from 'react';
  import ProfileAbout from './ProfileAbout';
  import ProfilePhotos from './ProfilePhotos';

  type Props = { profile: Profile };

  const ProfileContent = ({ profile }: Props) => {
    const [value, setValue] = useState(0);
    const handleChange = (_: SyntheticEvent, newValue: number) => setValue(newValue);

    const tabContent = [
      { label: 'About', content: <ProfileAbout profile={profile} /> },
      { label: 'Photos', content: <ProfilePhotos /> },
      { label: 'Events', content: <div>Events</div> },
      { label: 'Followers', content: <div>Followers</div> },
      { label: 'Following', content: <div>Following</div> },
    ];

    return (
      <Box component="paper" mt={2} p={3} elevation={3} sx={{ display: 'flex', borderRadius: 3, height: 500 }}>
        <Tabs
          orientation="vertical"
          value={value}
          onChange={handleChange}
          sx={{ borderRight: 1, height: 450, minWidth: 200 }}
        >
          {tabContent.map((tab, index) => (
            <Tab key={index} label={tab.label} sx={{ mr: 3 }} />
          ))}
        </Tabs>
        <Box sx={{ flexGrow: 1, p: 3 }}>
          {tabContent[value].content}
        </Box>
      </Box>
    );
  };

  export default ProfileContent;
  ```

### Key Idea
Tabs provide an intuitive way to organize profile content, allowing users to switch between sections seamlessly.

## Displaying Profile Photos

### Definition
Create a `ProfilePhotos` component to display user photos, with options to add, set as main, or delete photos for the current user.

### Implementation
- **Create `Photo` Type in `Index.ts`**:
  ```typescript
  type Photo = {
    id: string;
    url: string;
  };
  ```
- **Update `useProfile` Hook in `lib/hooks/useProfile.ts`**:
  ```typescript
  import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
  import { useMemo } from 'react';

  export const useProfile = (id?: string) => {
    const queryClient = useQueryClient();

    const { data: profile, isLoading: loadingProfile } = useQuery({
      queryKey: ['profile', id],
      queryFn: async () => {
        const response = await agent.get<Profile>(`/profiles/${id}`);
        return response.data;
      },
      enabled: !!id,
    });

    const { data: photos, isLoading: loadingPhotos } = useQuery({
      queryKey: ['photos', id],
      queryFn: async () => {
        const response = await agent.get<Photo[]>(`/profiles/${id}/photos`);
        return response.data;
      },
      enabled: !!id,
    });

    const isCurrentUser = useMemo(() => id === queryClient.getQueryData(['user'])?.id, [id, queryClient]);

    return { profile, loadingProfile, photos, loadingPhotos, isCurrentUser };
  };
  ```
- **Create `ProfilePhotos.tsx` in `features/profiles`**:
  ```jsx
  import { Box, Button, Divider, ImageList, ImageListItem, Typography } from '@mui/material';
  import { useParams } from 'react-router-dom';
  import { useProfile } from '../../lib/hooks/useProfile';
  import StarButton from '../shared/StarButton';
  import DeleteButton from '../shared/DeleteButton';
  import PhotoUploadWidget from '../shared/PhotoUploadWidget';

  const ProfilePhotos = () => {
    const { id } = useParams();
    const { photos, loadingPhotos, profile, isCurrentUser, uploadPhoto, setMainPhoto, deletePhoto } = useProfile(id);
    const [editMode, setEditMode] = useState(false);

    const handlePhotoUpload = (file: Blob) => {
      uploadPhoto.mutate(file, {
        onSuccess: () => setEditMode(false),
      });
    };

    if (loadingPhotos) return <Typography>Loading photos...</Typography>;

    return (
      <>
        {isCurrentUser && (
          <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
            <Typography variant="h5">Photos</Typography>
            <Button onClick={() => setEditMode(!editMode)}>
              {editMode ? 'Cancel' : 'Add Photo'}
            </Button>
          </Box>
        )}
        <Divider sx={{ my: 2 }} />
        {editMode ? (
          <PhotoUploadWidget uploadPhoto={handlePhotoUpload} loading={uploadPhoto.isPending} />
        ) : photos?.length === 0 ? (
          <Typography>No photos added yet</Typography>
        ) : (
          <ImageList cols={6}>
            {photos?.map(item => (
              <ImageListItem key={item.id}>
                <img
                  src={item.url.replace('/upload/', '/upload/w_164,h_164,c_crop,f_auto,g_face/')}
                  alt="User profile image"
                />
                {isCurrentUser && (
                  <div>
                    <Box sx={{ position: 'absolute', top: 0, left: 0 }}>
                      <StarButton selected={item.url === profile?.imageUrl} onClick={() => setMainPhoto.mutate(item)} />
                    </Box>
                    {item.url !== profile?.imageUrl && (
                      <Box sx={{ position: 'absolute', top: 0, right: 0 }}>
                        <DeleteButton onClick={() => deletePhoto.mutate(item.id)} />
                      </Box>
                    )}
                  </div>
                )}
              </ImageListItem>
            ))}
          </ImageList>
        )}
      </>
    );
  };

  export default ProfilePhotos;
  ```

### Key Idea
The `ProfilePhotos` component displays user photos in a grid, with Cloudinary transformations for square images and management options for the current user.

## Creating Photo Upload Widget

### Definition
Build a `PhotoUploadWidget` component using React Dropzone for file uploads and React Cropper for cropping.

### Implementation
- **Install Dependencies**:
  ```bash
  npm install react-dropzone
  npm install react-cropper
  ```
- **Create `PhotoUploadWidget.tsx` in `app/shared/components`**:
  ```jsx
  import { Box, Button, Grid2, Typography } from '@mui/material';
  import { useCallback, useEffect, useRef, useState } from 'react';
  import { useDropzone } from 'react-dropzone';
  import Cropper from 'react-cropper';
  import 'cropperjs/dist/cropper.css';
  import CloudUpload from '@mui/icons-material/CloudUpload';

  type Props = {
    uploadPhoto: (file: Blob) => void;
    loading: boolean;
  };

  const PhotoUploadWidget = ({ uploadPhoto, loading }: Props) => {
    const [files, setFiles] = useState<(File & { preview: string })[]>([]);
    const cropperRef = useRef<Cropper>(null);

    const onDrop = useCallback((acceptedFiles: File[]) => {
      setFiles(
        acceptedFiles.map(file =>
          Object.assign(file, { preview: URL.createObjectURL(file as Blob) })
        )
      );
    }, []);

    const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop });

    const onCrop = useCallback(() => {
      const cropper = cropperRef.current?.cropper;
      cropper?.getCroppedCanvas().toBlob(blob => uploadPhoto(blob as Blob));
    }, [uploadPhoto]);

    useEffect(() => {
      return () => {
        files.forEach(file => URL.revokeObjectURL(file.preview));
      };
    }, [files]);

    return (
      <Grid2 container spacing={3}>
        <Grid2 size={4}>
          <Typography variant="overline" color="secondary">Step 1 - Add Photo</Typography>
          <Box
            {...getRootProps()}
            sx={{
              border: `3px dashed ${isDragActive ? 'green' : '#eee'}`,
              borderRadius: 5,
              pt: '30px',
              textAlign: 'center',
              height: 280,
            }}
          >
            <input {...getInputProps()} />
            <CloudUpload sx={{ fontSize: 80 }} />
            <Typography variant="h5">Drop image here</Typography>
          </Box>
        </Grid2>
        <Grid2 size={4}>
          <Typography variant="overline" color="secondary">Step 2 - Resize Image</Typography>
          {files[0]?.preview && (
            <Cropper
              src={files[0].preview}
              style={{ height: 300, width: '90%' }}
              aspectRatio={1}
              initialAspectRatio={1}
              guides={false}
              viewMode={1}
              background={false}
              ref={cropperRef}
            />
          )}
        </Grid2>
        <Grid2 size={4}>
          <Typography variant="overline" color="secondary">Step 3 - Preview & Upload</Typography>
          {files[0]?.preview && (
            <>
              <div
                className="image-preview"
                style={{ width: 300, height: 300, overflow: 'hidden' }}
              />
              <Button
                sx={{ mt: 1, width: 300 }}
                variant="contained"
                color="secondary"
                disabled={loading}
                onClick={onCrop}
              >
                Upload
              </Button>
            </>
          )}
        </Grid2>
      </Grid2>
    );
  };

  export default PhotoUploadWidget;
  ```

### Key Idea
The `PhotoUploadWidget` provides a three-step process (add, resize, upload) for user-friendly photo management, with proper memory cleanup.

## Implementing Photo Management Mutations

### Definition
Add mutations in the `useProfile` hook for uploading, setting main, and deleting photos, updating the UI dynamically.

### Implementation
- **Update `useProfile` Hook**:
  ```typescript
  const uploadPhoto = useMutation({
    mutationFn: async (file: Blob) => {
      const formData = new FormData();
      formData.append('file', file);
      const response = await agent.post<Photo>('/profiles/add-photo', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data;
    },
    onSuccess: async (photo, _, { queryClient }) => {
      await queryClient.invalidateQueries(['photos', id]);
      queryClient.setQueryData(['user'], (user: User) => {
        if (!user) return user;
        return { ...user, imageUrl: user.imageUrl ?? photo.url };
      });
      queryClient.setQueryData(['profile', id], (profile: Profile) => {
        if (!profile) return profile;
        return { ...profile, imageUrl: profile.imageUrl ?? photo.url };
      });
    },
  });

  const setMainPhoto = useMutation({
    mutationFn: async (photo: Photo) => {
      await agent.put(`/profiles/${photo.id}/set-main`);
    },
    onSuccess: async (_, photo, { queryClient }) => {
      queryClient.setQueryData(['user'], (user: User) => {
        if (!user) return user;
        return { ...user, imageUrl: photo.url };
      });
      queryClient.setQueryData(['profile', id], (profile: Profile) => {
        if (!profile) return profile;
        return { ...profile, imageUrl: photo.url };
      });
    },
  });

  const deletePhoto = useMutation({
    mutationFn: async (photoId: string) => {
      await agent.delete(`/profiles/${photoId}/photos`);
    },
    onSuccess: async (_, photoId, { queryClient }) => {
      queryClient.setQueryData(['photos', id], (photos: Photo[]) => {
        return photos?.filter(x => x.id !== photoId);
      });
    },
  });

  return { profile, loadingProfile, photos, loadingPhotos, isCurrentUser, uploadPhoto, setMainPhoto, deletePhoto };
  ```

### Key Idea
Mutations update the UI instantly by setting query data, ensuring the main photo change reflects across components like `UserMenu` and `ProfileHeader`.

## Creating Star and Delete Buttons

### Definition
Create reusable `StarButton` and `DeleteButton` components for setting main photos and deleting photos.

### Implementation
- **In `app/shared/components/StarButton.tsx`**:
  ```jsx
  import { Box, Button } from '@mui/material';
  import StarBorderIcon from '@mui/icons-material/StarBorder';
  import StarIcon from '@mui/icons-material/Star';

  type Props = { selected: boolean; onClick: () => void };

  const StarButton = ({ selected, onClick }: Props) => {
    return (
      <Box sx={{ position: 'relative' }}>
        <Button sx={{ opacity: 0.8, transition: 'opacity 0.3s', cursor: 'pointer' }} onClick={onClick}>
          <StarBorderIcon sx={{ fontSize: 32, color: 'white', position: 'absolute' }} />
          <StarIcon
            sx={{
              fontSize: 28,
              color: selected ? 'yellow' : 'rgba(0,0,0,0.5)',
            }}
          />
        </Button>
      </Box>
    );
  };

  export default StarButton;
  ```
- **In `app/shared/components/DeleteButton.tsx`**:
  ```jsx
  import { Box, Button } from '@mui/material';
  import DeleteOutlineIcon from '@mui/icons-material/DeleteOutline';
  import DeleteIcon from '@mui/icons-material/Delete';

  type Props = { onClick: () => void };

  const DeleteButton = ({ onClick }: Props) => {
    return (
      <Box sx={{ position: 'relative' }}>
        <Button sx={{ opacity: 0.8, transition: 'opacity 0.3s', cursor: 'pointer' }} onClick={onClick}>
          <DeleteOutlineIcon sx={{ fontSize: 32, color: 'white', position: 'absolute' }} />
          <DeleteIcon sx={{ fontSize: 28, color: 'red' }} />
        </Button>
      </Box>
    );
  };

  export default DeleteButton;
  ```

### Key Idea
Reusable buttons enhance the UI by providing clear actions for setting main photos and deleting non-main photos, with visual feedback.

## Creating Profile About Page

### Definition
Build a `ProfileAbout` component to display user bio and placeholder edit functionality.

### Implementation
- **In `features/profiles/ProfileAbout.tsx`**:
  ```jsx
  import { Box, Button, Divider, Typography } from '@mui/material';
  import { useParams } from 'react-router-dom';
  import { useProfile } from '../../lib/hooks/useProfile';

  const ProfileAbout = () => {
    const { id } = useParams();
    const { profile } = useProfile(id);

    return (
      <Box>
        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
          <Typography variant="h5">About {profile?.displayName}</Typography>
          <Button>Edit Profile</Button>
        </Box>
        <Divider sx={{ my: 2 }} />
        <Box sx={{ overflow: 'auto', maxHeight: 350 }}>
          <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
            {profile?.bio ?? 'No description added yet'}
          </Typography>
        </Box>
      </Box>
    );
  };

  export default ProfileAbout;
  ```

### Key Idea
The `ProfileAbout` component sets up a foundation for displaying user bios, with styling to handle long text and placeholders for future editing.

## Updating Profile Card

### Definition
Enhance the `ProfileCard` component to display a truncated bio for hover previews.

### Implementation
- **In `app/shared/components/ProfileCard.tsx`**:
  ```jsx
  <Box sx={{ display: 'flex', flexDirection: 'column' }}>
    <Typography variant="h6">{profile.displayName}</Typography>
    {profile.bio && (
      <Typography
        variant="body2"
        sx={{ textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }}
      >
        {profile.bio}
      </Typography>
    )}
    {/* Following placeholder */}
  </Box>
  ```

### Key Idea
Adding a truncated bio to the `ProfileCard` improves the hover preview, making it more informative without overwhelming the UI.

## Fixing Bugs and Styling

### Definition
Address issues like login redirection, photo display conditions, and styling improvements.

### Implementation
- **Fix Login Redirection in `useAccount` Hook**:
  ```typescript
  useQuery({
    queryKey: ['user'],
    queryFn: async () => {
      const response = await agent.get<User>('/account');
      return response.data;
    },
  });
  ```
  - Remove `enabled` condition to ensure user data is fetched even on login/register pages.
- **Fix Photo Display in `ProfilePhotos.tsx`**:
  - Move `isCurrentUser` check to wrap only the button, ensuring itâ€™s always visible for the current user.
  - Use a `div` instead of a fragment in `ImageList` to resolve React rendering errors.
- **Styling Adjustments**:
  - In `ProfilePhotos.tsx`, add a header and divider:
    ```jsx
    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
      <Typography variant="h5">Photos</Typography>
      {isCurrentUser && <Button onClick={() => setEditMode(!editMode)}>{editMode ? 'Cancel' : 'Add Photo'}</Button>}
    </Box>
    <Divider sx={{ my: 2 }} />
    ```
  - In `PhotoUploadWidget.tsx`, adjust button styling:
    ```jsx
    <Button sx={{ my: 1, width: 300 }} ...>Upload</Button>
    ```
  - In `ProfileContent.tsx`, reduce top padding:
    ```jsx
    <Box sx={{ display: 'flex', borderRadius: 3, height: 500, pt: 0 }}>...</Box>
    ```

### Key Idea
Fixing bugs and refining styling ensures a polished user experience, addressing issues like memory leaks and UI inconsistencies.

## Key Commands Recap
- **Install Dependencies**:
  ```bash
  npm install react-dropzone
  npm install react-cropper
  ```
- **Run Application**:
  ```bash
  npm start
  ```
- **Commit Changes**:
  ```bash
  git add .
  git commit -m "End of section 17"
  git push
  ```

## Tips for Beginners
- **Check Cloudinary URLs**: Ensure transformation parameters (e.g., `w_164,h_164,c_crop,f_auto,g_face`) are correct to avoid display issues.
- **Handle TypeScript Errors**: Use proper types for `File` and `Blob` in `PhotoUploadWidget` to resolve TypeScript warnings.
- **Test with Different Users**: Verify that photo management options (add, set main, delete) are only visible for the current user.
- **Prevent Memory Leaks**: Always revoke `URL.createObjectURL` in a `useEffect` cleanup to avoid browser memory issues.
- **Debug Hot Reload Errors**: Refresh the browser to clear hot reload-related console errors during development.

## Next Steps
- Implement bio editing functionality in the `ProfileAbout` component.
- Add follower and following functionality to the profile tabs.
- Consider optimistic updates for setting the main photo to enhance UI responsiveness.
- Enhance error handling for failed uploads or deletions.