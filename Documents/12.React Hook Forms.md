# Section 11: Forms in React with React Hook Form and Zod

## Introduction to Forms

### Definition
Forms are a critical component of web applications, allowing users to input and submit data, such as creating or updating records like activities in our application.

### Purpose
Forms enable user interaction by collecting input for processing, storage, or display, enhancing the functionality and interactivity of web applications.

### Key Idea
Forms in React are made efficient and robust using libraries like React Hook Form for form management and Zod for validation, reducing boilerplate and improving user experience.

> **Analogy**: Think of a form as a digital clipboard where users fill out their details, and libraries like React Hook Form and Zod act as helpful assistants ensuring the clipboard is organized and the data is correct before submission.

## Learning Goals
- Understand how to implement forms in React using React Hook Form for state management.
- Learn to use Zod for creating validation schemas to ensure data integrity.
- Create reusable form components to reduce repetitive code.
- Implement advanced inputs like date pickers, select inputs, and location autocompletion.
- Display a map view for location-based inputs using Leaflet.

## Setting Up React Hook Form

### Overview
React Hook Form is a popular library for managing forms in React, known for its performance and minimal re-renders.

### Installation
Install React Hook Form and its dependencies:
```bash
npm install react-hook-form @hookform/resolvers
```

### Basic Setup
Use the `useForm` hook to initialize a form with React Hook Form:
```jsx
import { useForm } from 'react-hook-form';

const ActivityForm = () => {
  const { handleSubmit, control } = useForm();
  
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form inputs will go here */}
    </form>
  );
};
```

### Tips for Beginners
- React Hook Form minimizes re-renders by managing form state efficiently, unlike native React state management.
- Use `handleSubmit` to process form data safely, ensuring all inputs are registered correctly.

## Adding Validation with Zod

### Overview
Zod is a TypeScript-first schema validation library that integrates with React Hook Form to validate form inputs.

### Installation
Install Zod and the resolver for React Hook Form:
```bash
npm install zod @hookform/resolvers
```

### Creating a Validation Schema
Define a schema for the activity form in `lib/schemas/activitySchema.ts`:
```typescript
import { z } from 'zod';

const requiredString = (fieldName: string) => z.string().min(1, `${fieldName} is required`);

export const activitySchema = z.object({
  title: requiredString('Title'),
  description: requiredString('Description'),
  category: requiredString('Category'),
  date: z.coerce.date({ message: 'Date is required' }),
  location: z.object({
    venue: requiredString('Venue'),
    city: z.string().optional(),
    latitude: z.coerce.number(),
    longitude: z.coerce.number(),
  }),
});

export type ActivitySchema = z.infer<typeof activitySchema>;
```

### Integrating with React Hook Form
Use the Zod resolver to apply the schema:
```jsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { activitySchema } from '../lib/schemas/activitySchema';

const ActivityForm = () => {
  const { handleSubmit, control, formState: { errors } } = useForm({
    resolver: zodResolver(activitySchema),
    mode: 'onTouched', // Validate when field is touched
  });

  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Inputs with error handling */}
    </form>
  );
};
```

### Tips for Beginners
- Use `mode: 'onTouched'` to trigger validation when users interact with fields, improving UX.
- The `errors` object from `formState` provides validation messages for display.
- Create reusable validation functions like `requiredString` to reduce boilerplate.

## Creating a Reusable Text Input

### Overview
A reusable text input component simplifies form creation by encapsulating validation and styling logic.

### Implementation
Create `TextInput.tsx` in `app/shared/components`:
```tsx
import { useController, UseControllerProps } from 'react-hook-form';
import { TextField, TextFieldProps } from '@mui/material';

type Props<T> = {
  label: string;
} & UseControllerProps<T> & TextFieldProps;

export const TextInput = <T extends object>({ label, ...props }: Props<T>) => {
  const { field, fieldState } = useController(props);

  return (
    <TextField
      {...props}
      {...field}
      value={field.value ?? ''}
      label={label}
      fullWidth
      variant="outlined"
      error={!!fieldState.error}
      helperText={fieldState.error?.message}
    />
  );
};
```

### Usage in Form
Use the text input in the activity form:
```tsx
<TextInput
  control={control}
  name="title"
  label="Title"
/>
```

### Tips for Beginners
- Extend `UseControllerProps` and `TextFieldProps` to support both React Hook Form and Material-UI props.
- Use the `useController` hook to manage controlled inputs, ensuring compatibility with Material-UI components.

## Creating a Reusable Select Input

### Overview
A select input allows users to choose from predefined options, such as activity categories.

### Implementation
Create `SelectInput.tsx` in `app/shared/components`:
```tsx
import { useController, UseControllerProps } from 'react-hook-form';
import { FormControl, InputLabel, Select, MenuItem, FormHelperText } from '@mui/material';

type Item = { text: string; value: string };
type Props<T> = {
  label: string;
  items: Item[];
} & UseControllerProps<T> & Partial<SelectProps>;

export const SelectInput = <T extends object>({ label, items, ...props }: Props<T>) => {
  const { field, fieldState } = useController(props);

  return (
    <FormControl fullWidth error={!!fieldState.error}>
      <InputLabel>{label}</InputLabel>
      <Select {...field} value={field.value ?? ''} label={label}>
        {items.map((item) => (
          <MenuItem key={item.value} value={item.value}>
            {item.text}
          </MenuItem>
        ))}
      </Select>
      <FormHelperText>{fieldState.error?.message}</FormHelperText>
    </FormControl>
  );
};
```

### Category Options
Define options in `app/activities/form/categoryOptions.ts`:
```typescript
export const categoryOptions = [
  { text: 'Drinks', value: 'drinks' },
  { text: 'Culture', value: 'culture' },
  { text: 'Film', value: 'film' },
  { text: 'Food', value: 'food' },
  { text: 'Music', value: 'music' },
  { text: 'Travel', value: 'travel' },
];
```

### Usage in Form
```tsx
import { categoryOptions } from './categoryOptions';

<SelectInput
  control={control}
  name="category"
  label="Category"
  items={categoryOptions}
/>
```

### Tips for Beginners
- Use `FormControl` to wrap `Select` for better styling and error handling.
- Make `SelectProps` partial to avoid requiring unnecessary properties.

## Creating a Reusable DateTime Input

### Overview
A date-time picker provides a consistent UI for selecting dates and times across browsers.

### Installation
Install MUI X Date Pickers and date-fns:
```bash
npm install @mui/x-date-pickers date-fns
```

### Setup Localization Provider
Wrap the app in `LocalizationProvider` in `main.tsx`:
```tsx
import { LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFnsV3';

<LocalizationProvider dateAdapter={AdapterDateFns}>
  <App />
</LocalizationProvider>
```

### Implementation
Create `DateTimeInput.tsx` in `app/shared/components`:
```tsx
import { useController, UseControllerProps } from 'react-hook-form';
import { DateTimePicker, DateTimePickerProps } from '@mui/x-date-pickers';

type Props<T> = UseControllerProps<T> & DateTimePickerProps<Date>;

export const DateTimeInput = <T extends object>({ ...props }: Props<T>) => {
  const { field, fieldState } = useController(props);

  return (
    <DateTimePicker
      {...props}
      value={field.value ? new Date(field.value) : null}
      onChange={(value) => field.onChange(new Date(value!))}
      sx={{ width: '100%' }}
      slotProps={{
        textField: {
          onBlur: field.onBlur,
          error: !!fieldState.error,
          helperText: fieldState.error?.message,
        },
      }}
    />
  );
};
```

### Usage in Form
```tsx
<DateTimeInput
  control={control}
  name="date"
  label="Date and Time"
/>
```

### Tips for Beginners
- Use `AdapterDateFnsV3` for compatibility with date-fns version 3 or 4.
- Coerce string inputs to `Date` objects in the schema using `z.coerce.date()`.

## Creating a Location Autocomplete Input

### Overview
A location autocomplete input fetches suggestions from an API (e.g., LocationIQ) as the user types, providing venue, city, and coordinates.

### Installation
Install Axios for API requests:
```bash
npm install axios
```

### Setup LocationIQ
Sign up for a free LocationIQ account to obtain an API key. Use the autocomplete endpoint: `https://api.locationiq.com/v1/autocomplete`.

### Type Definitions
Define types in `index.ts`:
```typescript
export type LocationIQSuggestion = {
  place_id: string;
  osm_id: string;
  osm_type: string;
  lat: string;
  lon: string;
  display_name: string;
  address: LocationIQAddress;
};

export type LocationIQAddress = {
  city?: string;
  town?: string;
  village?: string;
};
```

### Implementation
Create `LocationInput.tsx` in `app/shared/components`:
```tsx
import { useState, useEffect, useMemo } from 'react';
import { useController, UseControllerProps } from 'react-hook-form';
import { TextField, Box, List, ListItemButton, Divider, Typography } from '@mui/material';
import axios from 'axios';
import { LocationIQSuggestion } from '../../index';

type Props<T> = { label: string } & UseControllerProps<T>;

export const LocationInput = <T extends object>({ label, ...props }: Props<T>) => {
  const { field, fieldState } = useController(props);
  const [loading, setLoading] = useState(false);
  const [suggestions, setSuggestions] = useState<LocationIQSuggestion[]>([]);
  const [inputValue, setInputValue] = useState(field.value?.venue ?? '');

  const locationUrl = `https://api.locationiq.com/v1/autocomplete?key=YOUR_API_KEY&limit=5&dedupe=1`;

  const fetchSuggestions = useMemo(
    () => debounce(async (query: string) => {
      if (!query || query.length < 3) {
        setSuggestions([]);
        return;
      }
      setLoading(true);
      try {
        const { data } = await axios.get<LocationIQSuggestion[]>(`${locationUrl}&q=${query}`);
        setSuggestions(data);
      } catch (error) {
        console.log(error);
      } finally {
        setLoading(false);
      }
    }, 500),
    [locationUrl]
  );

  useEffect(() => {
    setInputValue(typeof field.value === 'object' ? field.value.venue : field.value ?? '');
  }, [field.value]);

  const handleChange = async (value: string) => {
    field.onChange(value);
    setInputValue(value);
    await fetchSuggestions(value);
  };

  const handleSelect = (suggestion: LocationIQSuggestion) => {
    const city = suggestion.address.city ?? suggestion.address.town ?? suggestion.address.village ?? '';
    const venue = suggestion.display_name;
    const latitude = suggestion.lat;
    const longitude = suggestion.lon;
    setInputValue(venue);
    field.onChange({ city, venue, latitude, longitude });
    setSuggestions([]);
  };

  return (
    <Box>
      <TextField
        {...props}
        value={inputValue}
        onChange={(e) => handleChange(e.target.value)}
        label={label}
        fullWidth
        variant="outlined"
        error={!!fieldState.error}
        helperText={fieldState.error?.message}
      />
      {loading && <Typography>Loading...</Typography>}
      {suggestions.length > 0 && (
        <List sx={{ border: 1 }}>
          {suggestions.map((suggestion) => (
            <>
              <ListItemButton
                key={suggestion.place_id}
                onClick={() => handleSelect(suggestion)}
              >
                {suggestion.display_name}
              </ListItemButton>
              <Divider />
            </>
          ))}
        </List>
      )}
    </Box>
  );
};

const debounce = (func: Function, wait: number) => {
  let timeout: NodeJS.Timeout;
  return (...args: any[]) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};
```

### Usage in Form
```tsx
<LocationInput
  control={control}
  name="location"
  label="Enter the Location"
/>
```

### Tips for Beginners
- Use `useMemo` to memoize the debounced fetch function to prevent recreation on re-renders.
- Debounce API calls to avoid excessive requests, waiting 500ms after typing stops.
- Store the API key securely for production applications, avoiding exposure in client-side code.

## Displaying a Map with Leaflet

### Overview
Leaflet is an open-source JavaScript library for interactive maps, integrated into React via `react-leaflet`.

### Installation
Install Leaflet and React Leaflet:
```bash
npm install leaflet react-leaflet
npm install --save-dev @types/leaflet
```

### CSS Import
Add Leaflet CSS in `MapComponent.tsx`:
```tsx
import 'leaflet/dist/leaflet.css';
```

### Implementation
Create `MapComponent.tsx` in `app/shared/components`:
```tsx
import { MapContainer, TileLayer, Marker, Popup } from 'react-leaflet';

type Props = {
  position: [number, number];
  venue: string;
};

export const MapComponent = ({ position, venue }: Props) => {
  return (
    <MapContainer center={position} zoom={13} style={{ height: '100%' }}>
      <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
      <Marker position={position}>
        <Popup>{venue}</Popup>
      </Marker>
    </MapContainer>
  );
};
```

### Usage in Activity Details
In `ActivityDetailsInfo.tsx`:
```tsx
import { useState } from 'react';
import { Box, Button } from '@mui/material';
import { MapComponent } from '../shared/components/MapComponent';

const ActivityDetailsInfo = ({ activity }) => {
  const [mapOpen, setMapOpen] = useState(false);

  return (
    <>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography>{activity.venue}</Typography>
        <Typography>{activity.city}</Typography>
        <Button onClick={() => setMapOpen(!mapOpen)}>
          {mapOpen ? 'Hide Map' : 'Show Map'}
        </Button>
      </Box>
      {mapOpen && (
        <Box sx={{ height: 400, zIndex: 1000, display: 'block' }}>
          <MapComponent
            position={[activity.latitude, activity.longitude]}
            venue={activity.venue}
          />
        </Box>
      )}
    </>
  );
};
```

### Tips for Beginners
- Ensure the map container has a defined height (e.g., `height: '100%'`).
- Pass coordinates as a tuple `[latitude, longitude]`.
- Use a toggle state to show/hide the map for better UX.

## Submitting the Form

### Overview
Submitting the form involves flattening the data to match the server’s expected format and handling both create and update operations.

### Implementation
Update the `onSubmit` function in `ActivityForm.tsx`:
```tsx
import { useNavigate } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { activitySchema } from '../lib/schemas/activitySchema';

const ActivityForm = ({ activity, reset }) => {
  const navigate = useNavigate();
  const { handleSubmit, control, formState: { errors } } = useForm({
    resolver: zodResolver(activitySchema),
    mode: 'onTouched',
    defaultValues: activity ? {
      ...activity,
      location: {
        city: activity.city,
        venue: activity.venue,
        latitude: activity.latitude,
        longitude: activity.longitude,
      },
    } : {},
  });

  const onSubmit = async (data) => {
    const { location, ...rest } = data;
    const flattenedData = { ...rest, ...location };

    try {
      if (activity) {
        await updateActivity.mutate({
          ...activity,
          ...flattenedData,
        }, {
          onSuccess: () => navigate(`/activities/${activity.id}`),
        });
      } else {
        await createActivity.mutate(flattenedData, {
          onSuccess: ({ id }) => navigate(`/activities/${id}`),
        });
      }
    } catch (error) {
      console.log(error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <TextInput control={control} name="title" label="Title" />
      <TextInput control={control} name="description" label="Description" multiline rows={3} />
      <Box sx={{ display: 'flex', gap: 3 }}>
        <SelectInput control={control} name="category" label="Category" items={categoryOptions} />
        <DateTimeInput control={control} name="date" label="Date and Time" />
      </Box>
      <LocationInput control={control} name="location" label="Enter the Location" />
      <Button type="submit">Submit</Button>
    </form>
  );
};
```

### Tips for Beginners
- Use destructuring to flatten nested objects like `location` for server compatibility.
- Handle both create and update cases using conditional logic.
- Use `useNavigate` to redirect users after successful submission.

## Key Commands Recap
- `npm install react-hook-form @hookform/resolvers zod`: Install form management and validation libraries.
- `npm install @mui/x-date-pickers date-fns`: Install date picker dependencies.
- `npm install axios`: Install Axios for API requests.
- `npm install leaflet react-leaflet @types/leaflet --save-dev`: Install Leaflet for maps.

## Tips for Beginners
- Start with simple text inputs before tackling complex inputs like date pickers or autocompletion.
- Test validation by submitting empty forms to ensure error messages display correctly.
- Use TypeScript to catch errors early, but be prepared to override types (e.g., `!`) when using third-party libraries.
- Sign up for a free LocationIQ account for testing, but consider paid alternatives like Google Places for production apps.
- Always define heights for map containers to ensure proper rendering.

## Next Steps
- Practice creating additional reusable inputs for other form types.
- Explore advanced Zod validation rules (e.g., max length, regex).
- Experiment with Leaflet’s additional features, like custom markers or zoom controls.
- Review the form’s UX by testing with different browsers and devices.