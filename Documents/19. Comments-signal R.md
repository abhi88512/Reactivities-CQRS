# Section 19: Real-Time Functionality with SignalR

## Introduction to SignalR

### Definition
SignalR is a library in ASP.NET that enables real-time web functionality, allowing servers to push content to connected clients instantly.

### Purpose
SignalR facilitates live communication between clients and servers, ideal for applications like chat systems, dashboards, or monitoring tools that require immediate updates without constant server polling.

### Key Idea
SignalR maintains a persistent connection between client and server for real-time data exchange.

> **Analogy**: Think of SignalR as a phone call where both parties stay connected, allowing instant communication, unlike sending emails back and forth (traditional API requests).

## Learning Goals
- **Understand SignalR**: Learn what SignalR is and how it enables real-time communication.
- **Explore Transports**: Understand the different transport methods (WebSockets, Server-Sent Events, Long Polling) used by SignalR.
- **Implement SignalR**: Set up SignalR in a .NET and React application to enable real-time comment functionality for activities.

## SignalR Transports

### WebSockets
- **Definition**: A protocol providing a full-duplex, persistent connection between client and server.
- **Key Points**:
  - Supported by modern browsers (including Internet Explorer 10+).
  - Preferred transport for SignalR due to true two-way communication.
- **Code Example** (Conceptual):
  ```javascript
  // Client connects to SignalR hub via WebSockets
  const connection = new signalR.HubConnectionBuilder()
    .withUrl("http://localhost:5001/comments")
    .build();
  ```

### Server-Sent Events (SSE)
- **Definition**: A fallback transport where the server pushes updates to the client, but the client cannot send data back as efficiently.
- **Key Points**:
  - Supported by most browsers except Internet Explorer.
  - Less efficient than WebSockets but useful when WebSockets are unavailable.

### Long Polling
- **Definition**: A fallback where the client repeatedly sends requests that remain open until the server responds, then closes and reopens.
- **Key Points**:
  - Used for older browsers (e.g., Internet Explorer 9 and below).
  - Introduces latency due to connection resets.
  - Least efficient transport.

## SignalR Hub

### Definition
A SignalR Hub is a server-side component that manages client connections and communication, acting as the central point for real-time interactions.

### Key Components
- **Context Object**:
  - Provides `ConnectionId` (unique per client connection).
  - Accesses `UserIdentifier` (from authentication token).
  - Exposes `User` (ClaimsPrincipal for user claims).
  - Includes `HttpContext` for query strings and request details.
- **Clients Object**:
  - Allows targeting specific clients or groups:
    - `Clients.Caller`: The client initiating the request.
    - `Clients.Group`: Clients in a specific group (e.g., based on activity ID).
    - `Clients.Others`: All clients except the caller.
- **Code Example** (Server-Side Hub):
  ```csharp
  public class CommentHub : Hub
  {
      private readonly IMediator _mediator;

      public CommentHub(IMediator mediator)
      {
          _mediator = mediator;
      }

      public override async Task OnConnectedAsync()
      {
          var httpContext = Context.GetHttpContext();
          var activityId = httpContext?.Request.Query["activityId"];
          if (string.IsNullOrEmpty(activityId))
              throw new HubException("No activity with this ID");

          await Groups.AddToGroupAsync(Context.ConnectionId, activityId!);
          var result = await _mediator.Send(new GetComments.Query { ActivityId = activityId! });
          await Clients.Caller.SendAsync("LoadComments", result.Value);
      }

      public async Task SendComment(AddComment.Command command)
      {
          var comment = await _mediator.Send(command);
          await Clients.Group(command.ActivityId).SendAsync("ReceiveComment", comment.Value);
      }
  }
  ```

## Setting Up SignalR in .NET

### Steps
1. **Add SignalR Service**:
   - In `Program.cs`, add SignalR to the service collection.
   ```csharp
   builder.Services.AddSignalR();
   ```
2. **Map SignalR Hub**:
   - Configure the endpoint for the SignalR hub.
   ```csharp
   app.MapHub<CommentHub>("/comments");
   ```
3. **Create Comment Entity**:
   - Define the `Comment` class with properties and relationships.
   ```csharp
   public class Comment
   {
       public string Id { get; set; } = Guid.NewGuid().ToString();
       public required string Body { get; set; }
       public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
       public string UserId { get; set; } = null!;
       public User User { get; set; } = null!;
       public string ActivityId { get; set; } = null!;
       public Activity Activity { get; set; } = null!;
   }
   ```
4. **Update DbContext**:
   - Add a `DbSet` for comments and configure UTC conversion for `DateTime`.
   ```csharp
   public class AppDbContext : DbContext
   {
       public DbSet<Comment> Comments { get; set; } = null!;

       public AppDbContext(DbContextOptions options) : base(options)
       {
           var dateTimeConverter = new ValueConverter<DateTime, DateTime>(
               v => v.ToUniversalTime(),
               v => DateTime.SpecifyKind(v, DateTimeKind.Utc)
           );

           foreach (var entityType in Model.GetEntityTypes())
           {
               foreach (var property in entityType.GetProperties())
               {
                   if (property.ClrType == typeof(DateTime))
                       property.SetValueConverter(dateTimeConverter);
               }
           }
       }
   }
   ```
5. **Create Migration**:
   - Run `dotnet ef migrations add CommentEntityAdded -p Persistence -s API` to update the database schema.

## Setting Up SignalR on the Client (React)

### Installing SignalR Client
- Install the SignalR client package:
  ```bash
  npm install @microsoft/signalr
  ```

### Defining Comment Type
- Create a TypeScript interface for comments.
  ```typescript
  export type ChatComment = {
      id: string;
      createdAt: Date;
      body: string;
      userId: string;
      displayName: string;
      imageUrl?: string;
  };
  ```

### Creating a Custom Hook
- Use MobX for state management with a custom hook (`useComments`).
  ```typescript
  import { useEffect } from "react";
  import { useLocalObservable } from "mobx-react-lite";
  import { HubConnection, HubConnectionBuilder } from "@microsoft/signalr";
  import { runInAction } from "mobx";

  export const useComments = (activityId?: string) => {
      const created = useRef(false);

      const commentStore = useLocalObservable(() => ({
          hubConnection: null as HubConnection | null,
          comments: [] as ChatComment[],
          createHubConnection(activityId: string) {
              if (!activityId) return;

              this.hubConnection = new HubConnectionBuilder()
                  .withUrl(`${import.meta.env.VITE_COMMENTS_URL}?activityId=${activityId}`, { withCredentials: true })
                  .withAutomaticReconnect()
                  .build();

              this.hubConnection.start().catch((error) => console.log("Error establishing connection: ", error));

              this.hubConnection.on("LoadComments", (comments: ChatComment[]) => {
                  runInAction(() => {
                      this.comments = comments;
                  });
              });

              this.hubConnection.on("ReceiveComment", (comment: ChatComment) => {
                  runInAction(() => {
                      this.comments.unshift(comment);
                  });
              });
          },
          stopHubConnection() {
              if (this.hubConnection?.state === "Connected") {
                  this.hubConnection.stop().catch((error) => console.log("Error stopping connection: ", error));
                  this.comments = [];
              }
          },
      }));

      useEffect(() => {
          if (activityId && !created.current) {
              commentStore.createHubConnection(activityId);
              created.current = true;
          }
          return () => commentStore.stopHubConnection();
      }, [activityId, commentStore]);

      return { commentStore };
  };
  ```

### Integrating in React Component
- Use the hook in `ActivityDetailsChat` with React Hook Form and MobX observer.
  ```typescript
  import { observer } from "mobx-react-lite";
  import { useForm } from "react-hook-form";
  import { useParams } from "react-router-dom";
  import { useComments } from "../lib/hooks/useComments";
  import { formatDistanceToNow } from "../lib/utils";

  const ActivityDetailsChat = observer(() => {
      const { id } = useParams();
      const { commentStore } = useComments(id);
      const { register, handleSubmit, reset, formState: { isSubmitting } } = useForm<{ body: string }>();

      const addComment = async (data: { body: string }) => {
          try {
              await commentStore.hubConnection?.invoke("SendComment", { activityId: id, body: data.body });
              reset();
          } catch (error) {
              console.log(error);
          }
      };

      const handleKeyPress = (event: React.KeyboardEvent<HTMLDivElement>) => {
          if (event.key === "Enter" && !event.shiftKey) {
              event.preventDefault();
              handleSubmit(addComment)();
          }
      };

      return (
          <div>
              <form>
                  <TextField
                      {...register("body", { required: true })}
                      variant="outlined"
                      fullWidth
                      multiline
                      rows={2}
                      placeholder="Enter your comment (Enter to submit, Shift + Enter for new line)"
                      onKeyDown={handleKeyPress}
                      InputProps={{
                          endAdornment: isSubmitting ? <CircularProgress size={24} /> : null,
                      }}
                  />
              </form>
              <div style={{ height: 400, overflow: "auto" }}>
                  {commentStore.comments.map((comment) => (
                      <Box key={comment.id} display="flex">
                          <Avatar src={comment.imageUrl} alt="user" />
                          <Link to={`/profiles/${comment.userId}`}>{comment.displayName}</Link>
                          <span>{formatDistanceToNow(new Date(comment.createdAt))} ago</span>
                          <p>{comment.body}</p>
                      </Box>
                  ))}
              </div>
          </div>
      );
  });

  export default ActivityDetailsChat;
  ```

## Key Commands Recap
- **Add SignalR Service**:
  ```csharp
  builder.Services.AddSignalR();
  ```
- **Map SignalR Hub**:
  ```csharp
  app.MapHub<CommentHub>("/comments");
  ```
- **Install SignalR Client**:
  ```bash
  npm install @microsoft/signalr
  ```
- **Create Migration**:
  ```bash
  dotnet ef migrations add CommentEntityAdded -p Persistence -s API
  ```

## Tips for Beginners
- **Check Browser Compatibility**: Ensure your target browsers support WebSockets for optimal SignalR performance.
- **Use UTC for Dates**: Always store and send dates in UTC to avoid timezone issues, as shown in the `AppDbContext` configuration.
- **Avoid Typos in Method Names**: SignalR method names (e.g., `SendComment`, `LoadComments`) are case-sensitive and must match exactly between client and server.
- **Test in Browser**: Use the browserâ€™s developer tools (Network tab) to verify WebSocket connections and messages, as Postman is not ideal for testing SignalR.

## Next Steps
- Test the real-time comment functionality by opening multiple browser sessions (e.g., as different users) to verify comments appear instantly.
- Explore additional SignalR features, such as handling connection errors or adding more complex group-based notifications.
- Commit changes to source control to save your progress.