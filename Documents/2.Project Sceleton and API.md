# Section 2: Walking Skeleton Part 1 - API Focus

## What is a Walking Skeleton?

### Definition
A small, functional implementation of a system that performs a basic end-to-end task. In this course, it means retrieving data from a database via an API and displaying it in a browser.

### Purpose
Sets up the basic framework of the application, allowing architecture and functionality to evolve later.

### Key Idea
It doesn’t need the final architecture but connects the main components.

> **Quote by Alistair Cockburn:** A walking skeleton is a tiny implementation that links the main architectural components, allowing the architecture and functionality to evolve in parallel.

## Learning Goals

- **Understand Clean Architecture**: Learn the basics of organizing a project with a domain-centric approach.
- **Create .NET Projects**: Set up a Web API and supporting class libraries using the .NET CLI.
- **Use Entity Framework**: Connect to a database and map C# code to SQL queries.
- **Seed Data**: Populate the database with initial data for testing and resets.
- **Code-First Migrations**: Use Entity Framework to create and manage database schemas from code.
- **Test with Postman**: Verify API functionality by sending requests and checking responses.
- **Use Git**: Save the project in source control for version management.

## Clean Architecture Overview

### Domain-Centric Approach
The domain is the core of the application, containing business entities (e.g., an `Activity` entity for a social network app).

### Layers
- **Domain**: Contains business entities (e.g., `Activity` class). No dependencies on other layers.
- **Application**: Handles business logic, depends on the Domain layer.
- **API**: Receives and responds to HTTP requests, depends on the Application layer.
- **Persistence**: Connects to the database, depends on the Domain layer.

### Dependencies
`API` → `Application` → (`Domain`, `Persistence`).

The API has transitive access to `Domain` and `Persistence` via the `Application` layer.

### Key Takeaway
The **Domain** is central and independent, while other layers build around it.

## Project Setup with .NET CLI

### .NET CLI
Command-line tool for creating and managing .NET projects (part of the .NET SDK).

### Solution File
A container for multiple projects, created with:
```sh
dotnet new sln
```

### Projects Created
- **API Project**: A Web API project to handle HTTP requests.
  ```sh
  dotnet new webapi -n API --use-controllers
  ```
  > The `--use-controllers` flag ensures the project uses API controllers (not minimal APIs) for better structure.

- **Class Libraries**:
  - **Domain**: For business entities.
  - **Application**: For business logic.
  - **Persistence**: For database connections.
  ```sh
  dotnet new classlib -n Domain
  dotnet new classlib -n Application
  dotnet new classlib -n Persistence
  ```

### Add Projects to Solution
```sh
dotnet sln add API
dotnet sln add Application
dotnet sln add Domain
dotnet sln add Persistence
```

### Set Up Project References
- `API` references `Application`.
- `Application` references `Domain` and `Persistence`.
- `Persistence` references `Domain`.

> This can be done in VS Code via the Solution Explorer or by editing the `.csproj` files.

## Project Structure

### API Project
- Handles HTTP requests and responses.
- Contains a `Controllers` folder (due to `--use-controllers` flag).

### Application Project
- Processes business logic.
- Uses Domain entities and interacts with Persistence.

### Domain Project
- Contains business entities (e.g., `Activity` class for social activities).
- No dependencies on other projects.

### Persistence Project
- Manages database connections using Entity Framework.
- Translates C# code to SQL queries.

## Entity Framework (EF)

### What is it?
An Object-Relational Mapper (ORM) that connects C# code to a database.

### Purpose
- Maps C# classes to database tables.
- Converts C# code to SQL queries for data retrieval or updates.

### Code-First Migrations
- Allows creating and updating the database schema based on C# code.
- Useful for scaffolding the database structure.

### Seeding Data
- Populates the database with initial data.
- Enables resetting the database to a clean state with predefined data.

## Testing with Postman

### What is Postman?
A tool for testing APIs by sending HTTP requests and checking responses.

### Goal
Verify that the API can:
- Retrieve a list of activities from the database.
- Retrieve a single activity by ID.

### Why Use It?
Ensures the API works as expected before integrating with the front-end.

## Source Control with Git

### Purpose
Save and track changes to the project code.

### Steps
- Initialize a Git repository.
- Commit the project files to save progress.

### Why Important?
Allows version control and collaboration.

## What You’ll Achieve

### Starting Point
An empty folder with no code.

### End Result
- A .NET solution with `API`, `Application`, `Domain`, and `Persistence` projects.
- A database populated with activity data.
- An API that can return a list of activities or a single activity, tested via Postman.

### Key Outcome
A functional foundation (walking skeleton) for the application, ready for further development.

## Key Commands Recap

- Check .NET SDK version: `dotnet --info`
- List available templates: `dotnet new list`
- Create a solution: `dotnet new sln`
- Create a Web API project: `dotnet new webapi -n API --use-controllers`
- Create a class library: `dotnet new classlib -n <ProjectName>`
- Add projects to solution: `dotnet sln add <ProjectName>`

## Tips for Beginners

- **Don’t Panic About Architecture**: The clean architecture setup may seem complex, but it will make sense as you build the projects.
- **Focus on the Process**: Creating projects, setting references, and running the API are the main goals.
- **Use the .NET CLI**: It’s consistent across platforms and ensures the same setup as the instructor.
- **Check Your Setup**: Ensure the `Controllers` folder exists in the API project after creation.


