# Section 12: Introducing ASP.NET Core Identity

## Overview of ASP.NET Core Identity

### Definition
ASP.NET Core Identity is a membership system provided by Microsoft for managing user authentication and authorization in .NET applications. It supports local user accounts (email and password) and external provider logins, with built-in support for secure password storage and user management.

### Purpose
This system simplifies implementing user authentication and authorization in applications, providing a secure, battle-tested framework for managing user logins, registrations, and access control without requiring developers to build these features from scratch.

### Key Idea
ASP.NET Core Identity streamlines user management by providing pre-built tools like user stores, password hashing, and API endpoints for authentication tasks.

> **Analogy**: Think of ASP.NET Core Identity as a ready-made security guard for your application. It handles user registration, login, and access control, so you don’t have to build a custom security system from the ground up.

## Learning Goals
- **Understand ASP.NET Core Identity**: Learn how it integrates into a .NET application to manage user authentication.
- **Implement Identity Endpoints**: Use .NET 8’s identity API endpoints to handle user registration and login.
- **Secure API Endpoints**: Protect API endpoints to require authenticated users, using cookies for session management.
- **Seed Users**: Add initial users to the database for testing authentication workflows.

## ASP.NET Core Identity Setup

### What is ASP.NET Core Identity?
- A membership system that supports:
  - Local user logins (email/password).
  - External provider logins (e.g., Google, Facebook).
  - Default user stores (database tables for users, roles, claims, etc.).
- Provides **UserManager** for creating and managing users and **SignInManager** for handling user sign-ins.
- Uses a **cookie-based authentication** approach, where a secure cookie is issued upon login and sent with requests to authenticate users.

### Password Security
- **Hashing**: Passwords are hashed (a one-way operation) to prevent storing them in clear text.
- **Salting**: Adds a random string to each password before hashing, ensuring identical passwords have different hashes in the database.
  - Example: If Sally and Bob use the same password, their hashed passwords differ due to unique salts.
- **Security Benefit**: Makes it harder for hackers to reverse-engineer passwords if the database is compromised, requiring significant computational effort to crack each user’s password.

```csharp
// Password hashing and salting handled automatically by ASP.NET Core Identity
// Example of a hashed and salted password in the database:
PasswordHash: "AQAAAAEAACcQAAAA... (unique for each user)"
```

### Integration with Clean Architecture
- **Pragmatism**: ASP.NET Core Identity is treated as an external system to avoid tightly coupling it with the application’s domain layer.
- **Implementation Choice**: Instead of using a separate identity provider (e.g., IdentityServer), Identity is integrated directly into the application for simplicity in this training course.
- **No Handlers**: User registration and login are handled directly in API controllers, bypassing the clean architecture’s mediator pattern.

## Setting Up ASP.NET Core Identity

### Step 1: Install Required Package
- Install the `Microsoft.AspNetCore.Identity.EntityFrameworkCore` NuGet package in the domain project to enable Identity features.

```bash
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
```

### Step 2: Create a User Class
- Derive a custom `User` class from `IdentityUser` to add application-specific properties.

```csharp
using Microsoft.AspNetCore.Identity;

namespace Domain;

public class User : IdentityUser
{
    public string? DisplayName { get; set; }
    public string? Bio { get; set; }
    public string? ImageUrl { get; set; }
}
```

### Step 3: Update DbContext
- Modify the `AppDbContext` to inherit from `IdentityDbContext<User>` instead of `DbContext`.
- This enables Identity to create necessary database tables (e.g., `AspNetUsers`, `AspNetRoles`).

```csharp
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;

namespace Persistence;

public class AppDbContext : IdentityDbContext<User>
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
    {
    }
}
```

### Step 4: Add Migration
- Create a migration to generate Identity-related tables in the database.

```bash
dotnet ef migrations add IdentityAdded -p Persistence -s API
```

- Apply the migration to update the database.

```bash
dotnet ef database update -p Persistence -s API
```

### Step 5: Configure Identity in Program.cs
- Add Identity services and configure middleware in the `Program.cs` file.

```csharp
// Add Identity services
builder.Services.AddIdentityApiEndpoints<User>(opt =>
{
    opt.User.RequireUniqueEmail = true; // Enforce unique email addresses
})
.AddRoles<IdentityRole>()
.AddEntityFrameworkStores<AppDbContext>();

// Add middleware (order matters)
app.UseAuthentication();
app.UseAuthorization();

// Map Identity API endpoints
app.MapGroup("/api").MapIdentityApi<User>();
```

- **Note**: The `MapIdentityApi<User>` method automatically creates endpoints like `/api/login` and `/api/register`.

### Step 6: Update CORS for Cookies
- Allow credentials (cookies) in CORS configuration to support client-side requests.

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("CorsPolicy", builder =>
    {
        builder.AllowAnyMethod()
               .AllowAnyHeader()
               .AllowCredentials() // Required for cookies
               .WithOrigins("http://localhost:3000"); // Adjust to client URL
    });
});
```

## Seeding Users

### Purpose
Seed initial users into the database for testing authentication workflows.

### Implementation
- Update the `DbInitializer` class to use `UserManager<User>` for creating users.

```csharp
public static async Task SeedData(AppDbContext context, UserManager<User> userManager)
{
    if (!userManager.Users.Any())
    {
        var users = new List<User>
        {
            new User { DisplayName = "Bob", UserName = "bob@test.com", Email = "bob@test.com" },
            new User { DisplayName = "Tom", UserName = "tom@test.com", Email = "tom@test.com" },
            new User { DisplayName = "Jane", UserName = "jane@test.com", Email = "jane@test.com" }
        };

        foreach (var user in users)
        {
            await userManager.CreateAsync(user, "Pa$$w0rd"); // Complex password required
        }
    }
}
```

- Update `Program.cs` to inject `UserManager<User>` into the `SeedData` method.

```csharp
var userManager = app.Services.GetRequiredService<UserManager<User>>();
await DbInitializer.SeedData(context, userManager);
```

### Key Commands Recap
- **Install NuGet Package**:
  ```bash
  dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
  ```
- **Add Migration**:
  ```bash
  dotnet ef migrations add IdentityAdded -p Persistence -s API
  ```
- **Update Database**:
  ```bash
  dotnet ef database update -p Persistence -s API
  ```

## Protecting API Endpoints

### Applying Authorization
- By default, endpoints are accessible anonymously unless protected.
- Add the `[Authorize]` attribute to specific endpoints or create a global policy.

```csharp
[Authorize]
[HttpGet("{id}")]
public async Task<ActionResult<Activity>> GetActivity(Guid id)
{
    // Endpoint logic
}
```

### Global Authorization Policy
- Apply a global policy to require authentication for all endpoints, with exceptions for specific anonymous endpoints.

```csharp
builder.Services.AddControllers(opt =>
{
    var policy = new AuthorizationPolicyBuilder()
        .RequireAuthenticatedUser()
        .Build();
    opt.Filters.Add(new AuthorizeFilter(policy));
});
```

- Allow anonymous access to specific endpoints using `[AllowAnonymous]`.

```csharp
[AllowAnonymous]
[HttpGet]
public async Task<ActionResult<List<Activity>>> GetActivities()
{
    // Endpoint logic
}
```

## Custom Register Endpoint

### Why Custom?
- The default `/api/register` endpoint only accepts an email and password, but the application needs additional fields (e.g., `DisplayName`).

### Implementation
- Create a `RegisterDto` class for validation.

```csharp
using System.ComponentModel.DataAnnotations;

namespace API.Dtos;

public class RegisterDto
{
    [Required]
    public string DisplayName { get; set; } = string.Empty;
    
    [Required]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;
    
    public string Password { get; set; } = string.Empty; // Identity enforces complexity
}
```

- Create an `AccountController` to handle registration.

```csharp
[Route("api/account")]
[ApiController]
public class AccountController : ControllerBase
{
    private readonly SignInManager<User> _signInManager;

    public AccountController(SignInManager<User> signInManager)
    {
        _signInManager = signInManager;
    }

    [AllowAnonymous]
    [HttpPost("register")]
    public async Task<ActionResult> Register(RegisterDto registerDto)
    {
        var user = new User
        {
            UserName = registerDto.Email,
            Email = registerDto.Email,
            DisplayName = registerDto.DisplayName
        };

        var result = await _signInManager.UserManager.CreateAsync(user, registerDto.Password);

        if (result.Succeeded)
        {
            return Ok();
        }

        foreach (var error in result.Errors)
        {
            ModelState.AddModelError(error.Code, error.Description);
        }

        return ValidationProblem();
    }
}
```

## Getting Current User and Logging Out

### Get Current User
- Create an endpoint to retrieve information about the currently authenticated user.

```csharp
[AllowAnonymous]
[HttpGet("user-info")]
public async Task<ActionResult> GetUserInfo()
{
    if (!User.Identity?.IsAuthenticated ?? true)
    {
        return NoContent();
    }

    var user = await _signInManager.UserManager.GetUserAsync(User);

    if (user == null)
    {
        return Unauthorized();
    }

    return Ok(new
    {
        user.DisplayName,
        user.Email,
        user.Id,
        user.ImageUrl
    });
}
```

### Log Out
- Create an endpoint to sign out the user and remove the authentication cookie.

```csharp
[HttpPost("logout")]
public async Task<ActionResult> Logout()
{
    await _signInManager.SignOutAsync();
    return NoContent();
}
```

## Testing Authentication

### Login Endpoint
- Use the `/api/login` endpoint to authenticate users and receive a cookie.

```json
POST /api/login
{
    "email": "bob@test.com",
    "password": "Pa$$w0rd"
}
```

- **Response**: A `200 OK` with a secure, HTTP-only cookie (`AspNetCore.Identity.Application`).

### Verify Authentication
- Protected endpoints return `401 Unauthorized` if no valid cookie is present.
- With a valid cookie, requests to protected endpoints succeed (e.g., `200 OK` or `404 Not Found` for invalid IDs).

### Register Endpoint
- Test the custom `/api/account/register` endpoint.

```json
POST /api/account/register
{
    "displayName": "James",
    "email": "jim@test.com",
    "password": "Pa$$w0rd"
}
```

- **Success**: Returns `200 OK`.
- **Errors**: Returns validation errors for missing fields, duplicate emails, or weak passwords.

## Tips for Beginners
- **Use Complex Passwords**: ASP.NET Core Identity enforces complex passwords (minimum 6 characters, including uppercase, lowercase, digits, and non-alphanumeric characters). Use something like `Pa$$w0rd` to avoid silent failures.
- **Check Middleware Order**: Ensure `UseAuthentication` comes before `UseAuthorization` in `Program.cs` to avoid `401 Unauthorized` errors.
- **Understand Cookies vs. Tokens**: Cookies are secure and HTTP-only, making them safer than tokens for browser-based apps, but tokens are better for mobile apps.
- **Test with Postman**: Use Postman to verify cookies are set and sent with requests. Clear cookies between tests to simulate unauthenticated states.
- **Pragmatism Over Purity**: While clean architecture is ideal, integrating Identity directly into the application is a practical choice for simpler projects or learning purposes.

## Next Steps
- Test the authentication system using Postman to ensure login, registration, and protected endpoints work as expected.
- Explore integrating Identity with the client-side application (e.g., React) to handle user login and display user information.
- Consider adding additional user fields or custom validation to the registration process as needed.