# Section 14: Entity Framework Relationships

## Overview
This section focuses on establishing relationships between entities in a .NET application using Entity Framework (EF) Core, specifically for a many-to-many relationship between `Activity` and `User` entities. It covers configuring relationships, loading related data, using AutoMapper for projections, and implementing an infrastructure project for user authentication.

### Definition
Entity Framework Relationships define how entities (tables) in a database relate to each other, such as one-to-one, one-to-many, or many-to-many, enabling data connections like users attending activities.

### Purpose
Understanding and configuring relationships allows developers to model real-world interactions in the database, ensuring data integrity and enabling efficient querying of related data.

### Key Idea
Entity Framework simplifies relationship configuration through conventions, manual join tables, or explicit configurations to manage complex data interactions.

> **Analogy**: Think of Entity Framework relationships like a social network. Users (people) can attend many activities (events), and activities can have many attendees, just like friends can join multiple groups, and groups can have multiple members.

## Learning Goals
- **Understand EF Relationships**: Learn to configure one-to-one, one-to-many, and many-to-many relationships.
- **Load Related Data**: Explore eager loading, explicit loading, and lazy loading to retrieve related entities.
- **Use AutoMapper Query Extensions**: Project database queries into DTOs to avoid serialization issues and improve efficiency.
- **Implement Infrastructure Project**: Create a separate project to handle authentication and user access without affecting the application layer.

## Entity Framework Relationships

### Types of Relationships
- **One-to-One**: Example: A user has one address. Each user is linked to a single address entity with fields like street name or city.
- **One-to-Many**: Example: A user can have multiple photos. EF automatically configures a foreign key from the photos table to the user table.
- **Many-to-Many**: Example: Users can attend multiple activities, and activities can have multiple attendees. Requires a join table to manage relationships.

### Many-to-Many Relationship Configuration
- **By Convention**: Adding navigation properties (e.g., `ICollection<User> Attendees` in `Activity` and `ICollection<Activity> Activities` in `User`) allows EF to create a join table automatically.
  ```csharp
  public class Activity
  {
      public string Id { get; set; }
      public ICollection<User> Attendees { get; set; } = new List<User>();
  }

  public class User
  {
      public string Id { get; set; }
      public ICollection<Activity> Activities { get; set; } = new List<Activity>();
  }
  ```
- **Manual Join Table**: For additional properties (e.g., `IsHost`, `DateJoined`), create a custom join table like `ActivityAttendee`.
  ```csharp
  public class ActivityAttendee
  {
      public string? UserId { get; set; }
      public User? User { get; set; }!
      public string? ActivityId { get; set; }
      public Activity? Activity { get; set; }!
      public bool IsHost { get; set; }
      public DateTime DateJoined { get; set; } = DateTime.UtcNow;
  }
  ```

### Configuring Relationships in DbContext
- Use `OnModelCreating` to define the join table’s primary key and relationships explicitly.
  ```csharp
  protected override void OnModelCreating(ModelBuilder builder)
  {
      base.OnModelCreating(builder);
      builder.Entity<ActivityAttendee>()
          .HasKey(a => new { a.ActivityId, a.UserId });

      builder.Entity<ActivityAttendee>()
          .HasOne(a => a.User)
          .WithMany(u => u.Activities)
          .HasForeignKey(a => a.UserId);

      builder.Entity<ActivityAttendee>()
          .HasOne(a => a.Activity)
          .WithMany(a => a.Attendees)
          .HasForeignKey(a => a.ActivityId);
  }
  ```

### Adding Migration
- Create a migration to apply the join table to the database.
  ```bash
  dotnet ef migrations add ActivityAttendeesAdded -p Persistence -s API
  ```

## Loading Related Data

### Eager Loading
- Explicitly load related data using `Include` and `ThenInclude`.
  ```csharp
  var activity = await context.Activities
      .Include(x => x.Attendees)
      .ThenInclude(x => x.User)
      .FirstOrDefaultAsync(x => x.Id == request.Id);
  ```
- **Issue**: Can cause serialization cycles (e.g., `Activity` → `Attendees` → `User` → `Activities`).

### Lazy Loading
- Automatically loads related data when accessed but can lead to performance issues due to unintended queries. Not used in this section.

### Explicit Loading
- Loads related data after the initial query. Not used here due to lack of necessity.

### Projection with AutoMapper
- Use AutoMapper’s `ProjectTo` to select only needed properties, avoiding serialization issues and improving performance.
  ```csharp
  var activity = await context.Activities
      .ProjectTo<ActivityDto>(mapper.ConfigurationProvider)
      .FirstOrDefaultAsync(x => x.Id == request.Id);
  ```

## AutoMapper Query Extensions

### Definition
AutoMapper Query Extensions (`ProjectTo`) allow projecting database queries directly into DTOs, reducing the data retrieved and avoiding serialization cycles.

### Purpose
Improves query efficiency by selecting only required fields and maps directly to DTOs, bypassing entity serialization issues.

### Example: Activity DTO
```csharp
public class ActivityDto
{
    public string Id { get; set; } = null!;
    public string Title { get; set; } = null!;
    public DateTime Date { get; set; }
    public string Description { get; set; } = null!;
    public string Category { get; set; } = null!;
    public bool IsCancelled { get; set; }
    public string City { get; set; } = null!;
    public string Venue { get; set; } = null!;
    public string HostDisplayName { get; set; } = null!;
    public string HostId { get; set; } = null!;
    public ICollection<UserProfile> Attendees { get; set; } = new List<UserProfile>();
}
```

### Example: User Profile DTO
```csharp
public class UserProfile
{
    public string Id { get; set; } = null!;
    public string DisplayName { get; set; } = null!;
    public string? Bio { get; set; }
    public string? ImageUrl { get; set; }
}
```

### AutoMapper Configuration
- Map `Activity` to `ActivityDto` and `ActivityAttendee` to `UserProfile`.
  ```csharp
  CreateMap<Activity, ActivityDto>()
      .ForMember(d => d.HostDisplayName, o => o.MapFrom(s => s.Attendees.FirstOrDefault(x => x.IsHost)!.User.DisplayName))
      .ForMember(d => d.HostId, o => o.MapFrom(s => s.Attendees.FirstOrDefault(x => x.IsHost)!.UserId));

  CreateMap<ActivityAttendee, UserProfile>()
      .ForMember(d => d.Id, o => o.MapFrom(s => s.UserId))
      .ForMember(d => d.DisplayName, o => o.MapFrom(s => s.User.DisplayName))
      .ForMember(d => d.Bio, o => o.MapFrom(s => s.User.Bio))
      .ForMember(d => d.ImageUrl, o => o.MapFrom(s => s.User.ImageUrl));
  ```

## Infrastructure Project

### Definition
An infrastructure project handles external concerns like authentication, keeping the application layer independent of implementation details.

### Purpose
Ensures clean architecture by isolating authentication logic, making the application layer reusable across different project types (e.g., API or console).

### Implementation: User Accessor
- Create an interface in the application layer:
  ```csharp
  public interface IUserAccessor
  {
      string GetUserId();
      Task<User> GetUserAsync();
  }
  ```
- Implement in the infrastructure project:
  ```csharp
  public class UserAccessor(IHttpContextAccessor httpContextAccessor, AppDbContext dbContext) : IUserAccessor
  {
      public string GetUserId()
      {
          return httpContextAccessor.HttpContext?.User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new Exception("No user found");
      }

      public async Task<User> GetUserAsync()
      {
          return await dbContext.Users.FindAsync(GetUserId()) ?? throw new UnauthorizedAccessException("No user is logged in");
      }
  }
  ```
- Register in `Program.cs`:
  ```csharp
  builder.Services.AddScoped<IUserAccessor, UserAccessor>();
  ```

## Custom Authorization for Activity Editing

### Definition
A custom authorization policy ensures only the host of an activity can edit or delete it.

### Implementation
- Create an authorization requirement and handler:
  ```csharp
  public class IsHostRequirement : IAuthorizationRequirement
  {
  }

  public class IsHostRequirementHandler(AppDbContext dbContext, IHttpContextAccessor httpContextAccessor) 
      : AuthorizationHandler<IsHostRequirement>
  {
      protected override async Task HandleRequirementAsync(AuthorizationHandlerContext context, IsHostRequirement requirement)
      {
          var userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier);
          if (userId == null) return;

          if (httpContextAccessor.HttpContext?.GetRouteValue("id") is not string activityId) return;

          var attendee = await dbContext.ActivityAttendees
              .AsNoTracking()
              .SingleOrDefaultAsync(x => x.UserId == userId && x.ActivityId == activityId);

          if (attendee == null) return;

          if (attendee.IsHost) context.Succeed(requirement);
      }
  }
  ```
- Register in `Program.cs`:
  ```csharp
  builder.Services.AddAuthorization(opt =>
  {
      opt.AddPolicy("IsActivityHost", policy => policy.Requirements.Add(new IsHostRequirement()));
  });
  builder.Services.AddTransient<IAuthorizationHandler, IsHostRequirementHandler>();
  ```
- Apply to controller:
  ```csharp
  [Authorize(Policy = "IsActivityHost")]
  [HttpPut("{id}")]
  public async Task<ActionResult> Edit(string id, Activity activity)
  {
      activity.Id = id;
      return HandleResult(await Mediator.Send(new Edit.Command { Activity = activity }));
  }
  ```

### Fixing Entity Framework Tracking Bug
- Issue: Querying `ActivityAttendee` in the authorization handler caused EF to track the entity, leading to unintended attendee removal during activity edits.
- Fix: Use `AsNoTracking()` to prevent EF from tracking the attendee.
  ```csharp
  var attendee = await dbContext.ActivityAttendees
      .AsNoTracking()
      .SingleOrDefaultAsync(x => x.UserId == userId && x.ActivityId == activityId);
  ```

## Updating Attendance

### Definition
A handler toggles user attendance or activity cancellation based on the user’s role (host or attendee).

### Implementation
```csharp
public class UpdateAttendance
{
    public class Command : IRequest<Result<Unit>>
    {
        public string Id { get; set; } = null!;
    }

    public class Handler : IRequestHandler<Command, Result<Unit>>
    {
        private readonly AppDbContext _context;
        private readonly IUserAccessor _userAccessor;

        public Handler(AppDbContext context, IUserAccessor userAccessor)
        {
            _context = context;
            _userAccessor = userAccessor;
        }

        public async Task<Result<Unit>> Handle(Command request, CancellationToken cancellationToken)
        {
            var activity = await _context.Activities
                .Include(x => x.Attendees)
                .ThenInclude(x => x.User)
                .FirstOrDefaultAsync(x => x.Id == request.Id, cancellationToken);

            if (activity == null) return Result<Unit>.Failure("Activity not found", 404);

            var user = await _userAccessor.GetUserAsync();
            var attendance = activity.Attendees.FirstOrDefault(x => x.UserId == user.Id);
            var isHost = activity.Attendees.Any(x => x.IsHost && x.UserId == user.Id);

            if (attendance != null)
            {
                if (isHost)
                    activity.IsCancelled = !activity.IsCancelled;
                else
                    activity.Attendees.Remove(attendance);
            }
            else
            {
                activity.Attendees.Add(new ActivityAttendee
                {
                    UserId = user.Id,
                    ActivityId = activity.Id,
                    IsHost = false
                });
            }

            var result = await _context.SaveChangesAsync(cancellationToken) > 0;
            return result ? Result<Unit>.Success(Unit.Value) : Result<Unit>.Failure("Problem updating the DB", 400);
        }
    }
}
```

## Key Commands Recap
- **Add Migration**: `dotnet ef migrations add ActivityAttendeesAdded -p Persistence -s API` - Creates a migration for the join table.
- **Remove Migration**: `dotnet ef migrations remove -p Persistence -s API` - Removes a migration if needed.
- **Drop Database**: `dotnet ef database drop -p Persistence -s API` - Deletes the database for reseeding.
- **Run API**: `dotnet watch` - Starts the API with hot reload.

## Tips for Beginners
- **Understand EF Conventions**: EF can automatically configure relationships using navigation properties, but manual join tables offer more flexibility for additional properties.
- **Avoid Serialization Cycles**: Use DTOs and AutoMapper projections to shape data and prevent JSON serialization issues.
- **Use AsNoTracking for Read-Only Queries**: Prevents EF from tracking entities unnecessarily, avoiding bugs like unintended data modifications.
- **Restart API After Changes**: Always restart the API server after code changes to ensure updates are applied, especially during debugging.
- **Check Logs for SQL Queries**: Set `Microsoft.AspNetCore` to `Information` in `appsettings.Development.json` to view SQL queries for optimization.

## Next Steps
- Reseed the database with activities that include attendees to ensure consistent data for testing.
- Move to the client-side (React) to display activities and attendees, leveraging the relationships established in this section.