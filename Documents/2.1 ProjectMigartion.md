# Complete Guide: Migrating from Traditional Architecture to CQRS

## Table of Contents
1. [What We're Building](#what-were-building)
2. [Understanding the Concepts](#understanding-the-concepts)
3. [Project Structure Comparison](#project-structure-comparison)
4. [Step-by-Step Migration Guide](#step-by-step-migration-guide)
5. [Code Examples](#code-examples)
6. [Common Patterns](#common-patterns)
7. [Tips and Best Practices](#tips-and-best-practices)

---

## What We're Building

We're transforming your current web API from a traditional 3-layer architecture to a modern CQRS (Command Query Responsibility Segregation) pattern with Clean Architecture.

### Why Make This Change?

- **Better Organization**: Each operation has its own file and handler
- **Easier Testing**: You can test each feature independently
- **Clearer Code**: Commands change data, Queries read data - simple!
- **Better Performance**: Optimize reads and writes separately
- **Team Friendly**: Multiple developers can work without conflicts

---

## Understanding the Concepts

### Simple Definitions

**CQRS** = Separate reading data from writing data
- **Command**: "Do something" (Create, Update, Delete)
- **Query**: "Get something" (Read, Fetch, List)

**Clean Architecture Layers**:
1. **API Layer**: The door to your application (Controllers, Middleware)
2. **Application Layer**: The brain (Business logic, Commands, Queries)
3. **Domain Layer**: The heart (Core business objects)
4. **Persistence Layer**: The memory (Database operations)

Think of it like a restaurant:
- **API**: The waiter taking orders
- **Application**: The kitchen manager organizing work
- **Domain**: The recipes and ingredients
- **Persistence**: The storage room

---

## Project Structure Comparison

### Your Current Structure
```
YourProject/
├── Controllers/        (API endpoints)
├── Services/          (Business logic)
├── IServices/         (Service contracts)
├── Repositories/      (Database operations)
├── IRepositories/     (Repository contracts)
├── Models/           (Data structures)
├── DTOs/             (Data transfer objects)
├── Middleware/       (Request processing)
└── Extensions/       (Helper methods)
```

### New CQRS Structure
```
YourSolution/
├── YourProject.API/              (Presentation Layer)
│   ├── Controllers/              (Same as before)
│   ├── Middleware/              (Same as before)
│   ├── Extensions/              (Same as before)
│   └── Program.cs               (Startup configuration)
│
├── YourProject.Application/      (Business Logic Layer)
│   ├── Commands/                (Write operations)
│   │   └── Orders/
│   │       ├── CreateOrder/
│   │       │   ├── CreateOrderCommand.cs         (What data we need)
│   │       │   ├── CreateOrderCommandHandler.cs  (How to process it)
│   │       │   └── CreateOrderCommandValidator.cs (Validation rules)
│   │       └── UpdateOrder/
│   │           └── ... (same pattern)
│   │
│   ├── Queries/                 (Read operations)
│   │   └── Orders/
│   │       ├── GetOrderById/
│   │       │   ├── GetOrderByIdQuery.cs         (What we're looking for)
│   │       │   ├── GetOrderByIdQueryHandler.cs  (How to find it)
│   │       │   └── OrderDto.cs                  (What we return)
│   │       └── GetAllOrders/
│   │           └── ... (same pattern)
│   │
│   └── Common/
│       ├── Interfaces/         (Contracts)
│       ├── Behaviors/          (Cross-cutting concerns)
│       └── Exceptions/         (Custom exceptions)
│
├── YourProject.Domain/          (Core Business Layer)
│   ├── Entities/               (Business objects)
│   ├── ValueObjects/           (Complex types)
│   ├── Enums/                  (Fixed values)
│   └── Events/                 (Things that happened)
│
└── YourProject.Persistence/    (Data Access Layer)
    ├── Context/                (Database connection)
    ├── Configurations/         (Database mappings)
    └── Migrations/             (Database changes)
```

---

## Step-by-Step Migration Guide

### Phase 1: Set Up New Projects

#### 1.1 Create Solution Structure
```bash
# Create solution
dotnet new sln -n YourProject

# Create projects
dotnet new webapi -n YourProject.API
dotnet new classlib -n YourProject.Application
dotnet new classlib -n YourProject.Domain
dotnet new classlib -n YourProject.Persistence

# Add projects to solution
dotnet sln add YourProject.API
dotnet sln add YourProject.Application
dotnet sln add YourProject.Domain
dotnet sln add YourProject.Persistence
```

#### 1.2 Set Up Project References
```bash
# API depends on Application
dotnet add YourProject.API reference YourProject.Application

# Application depends on Domain
dotnet add YourProject.Application reference YourProject.Domain

# Persistence depends on Application
dotnet add YourProject.Persistence reference YourProject.Application
```

#### 1.3 Install Required Packages

**API Project:**
```xml
<PackageReference Include="MediatR" Version="12.1.1" />
<PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
```

**Application Project:**
```xml
<PackageReference Include="MediatR" Version="12.1.1" />
<PackageReference Include="FluentValidation" Version="11.8.0" />
<PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.8.0" />
<PackageReference Include="AutoMapper" Version="12.0.1" />
<PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" Version="12.0.1" />
<PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" />
```

**Persistence Project:**
```xml
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.0" />
```

---

### Phase 2: Migrate Models to Domain Entities

#### What Changes?
Your models become smarter! They now contain business rules and protect their data.

#### Old Model (What you have now):
```csharp
// Models/Order.cs
public class Order
{
    public int Id { get; set; }
    public string CustomerName { get; set; }
    public decimal Total { get; set; }
    public DateTime CreatedAt { get; set; }
    public string Status { get; set; }
}
```

#### New Domain Entity (What it becomes):
```csharp
// Domain/Entities/Order.cs
namespace YourProject.Domain.Entities;

public class Order
{
    // Private setters = data protection
    public int Id { get; private set; }
    public string OrderNumber { get; private set; }
    public string CustomerName { get; private set; }
    public string CustomerEmail { get; private set; }
    public string ShippingAddress { get; private set; }
    public decimal Total { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? UpdatedAt { get; private set; }
    public OrderStatus Status { get; private set; }
    
    // Navigation properties
    private readonly List<OrderItem> _items = new();
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    
    // Constructor enforces business rules
    public Order(string customerName, string customerEmail, string shippingAddress, decimal total)
    {
        // Business rule: Customer name is required
        if (string.IsNullOrWhiteSpace(customerName))
            throw new ArgumentException("Customer name cannot be empty");
        
        // Business rule: Valid email required
        if (string.IsNullOrWhiteSpace(customerEmail) || !customerEmail.Contains("@"))
            throw new ArgumentException("Valid email is required");
        
        // Business rule: Shipping address required
        if (string.IsNullOrWhiteSpace(shippingAddress))
            throw new ArgumentException("Shipping address is required");
        
        // Business rule: Total must be positive
        if (total <= 0)
            throw new ArgumentException("Order total must be greater than zero");
        
        CustomerName = customerName;
        CustomerEmail = customerEmail;
        ShippingAddress = shippingAddress;
        Total = total;
        CreatedAt = DateTime.UtcNow;
        Status = OrderStatus.Pending;
    }
    
    // Business methods (not just properties!)
    public void SetOrderNumber(string orderNumber)
    {
        if (string.IsNullOrWhiteSpace(orderNumber))
            throw new ArgumentException("Order number cannot be empty");
        
        OrderNumber = orderNumber;
    }
    
    public void AddItem(OrderItem item)
    {
        if (item == null)
            throw new ArgumentNullException(nameof(item));
        
        // Business rule: Cannot add items to cancelled or delivered orders
        if (Status == OrderStatus.Cancelled || Status == OrderStatus.Delivered)
            throw new InvalidOperationException("Cannot add items to completed or cancelled orders");
        
        _items.Add(item);
        UpdatedAt = DateTime.UtcNow;
    }
    
    public void RemoveItem(int productId)
    {
        var item = _items.FirstOrDefault(i => i.ProductId == productId);
        if (item != null)
        {
            _items.Remove(item);
            UpdatedAt = DateTime.UtcNow;
        }
    }
    
    public void MarkAsShipped()
    {
        if (Status != OrderStatus.Pending)
            throw new InvalidOperationException("Only pending orders can be shipped");
        
        Status = OrderStatus.Shipped;
        UpdatedAt = DateTime.UtcNow;
    }
    
    public void MarkAsDelivered()
    {
        if (Status != OrderStatus.Shipped)
            throw new InvalidOperationException("Only shipped orders can be marked as delivered");
        
        Status = OrderStatus.Delivered;
        UpdatedAt = DateTime.UtcNow;
    }
    
    public void Cancel()
    {
        if (Status == OrderStatus.Delivered)
            throw new InvalidOperationException("Cannot cancel delivered orders");
        
        Status = OrderStatus.Cancelled;
        UpdatedAt = DateTime.UtcNow;
    }
}

// Domain/Entities/OrderItem.cs
namespace YourProject.Domain.Entities;

public class OrderItem
{
    public int Id { get; private set; }
    public int OrderId { get; private set; }
    public int ProductId { get; private set; }
    public string ProductName { get; private set; }
    public int Quantity { get; private set; }
    public decimal Price { get; private set; }
    
    // Navigation property
    public Order Order { get; private set; }
    
    public OrderItem(int orderId, int productId, string productName, int quantity, decimal price)
    {
        if (quantity <= 0)
            throw new ArgumentException("Quantity must be greater than zero");
        
        if (price < 0)
            throw new ArgumentException("Price cannot be negative");
        
        if (string.IsNullOrWhiteSpace(productName))
            throw new ArgumentException("Product name is required");
        
        OrderId = orderId;
        ProductId = productId;
        ProductName = productName;
        Quantity = quantity;
        Price = price;
    }
    
    public decimal GetLineTotal() => Quantity * Price;
}

// Domain/Entities/Product.cs (Referenced in create/delete)
namespace YourProject.Domain.Entities;

public class Product
{
    public int Id { get; private set; }
    public string Name { get; private set; }
    public decimal Price { get; private set; }
    public int StockQuantity { get; private set; }
    
    public Product(string name, decimal price, int stockQuantity)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Product name is required");
        
        if (price <= 0)
            throw new ArgumentException("Price must be greater than zero");
        
        if (stockQuantity < 0)
            throw new ArgumentException("Stock cannot be negative");
        
        Name = name;
        Price = price;
        StockQuantity = stockQuantity;
    }
    
    public void ReduceStock(int quantity)
    {
        if (quantity <= 0)
            throw new ArgumentException("Quantity must be positive");
        
        if (StockQuantity < quantity)
            throw new InvalidOperationException("Insufficient stock");
        
        StockQuantity -= quantity;
    }
    
    public void IncreaseStock(int quantity)
    {
        if (quantity <= 0)
            throw new ArgumentException("Quantity must be positive");
        
        StockQuantity += quantity;
    }
}

// Domain/Enums/OrderStatus.cs
public enum OrderStatus
{
    Pending,
    Shipped,
    Delivered,
    Cancelled
}

// Domain/Entities/AuditLog.cs (For tracking deletions)
namespace YourProject.Domain.Entities;

public class AuditLog
{
    public int Id { get; set; }
    public string EntityName { get; set; }
    public int EntityId { get; set; }
    public string Action { get; set; }
    public string Reason { get; set; }
    public string DeletedData { get; set; }
    public string DeletedBy { get; set; }
    public DateTime DeletedAt { get; set; }
}
```

---

### Phase 3: Convert Services to Commands and Queries

#### Understanding the Change
Instead of one big service with many methods, each operation gets its own handler.

#### Old Service Pattern:
```csharp
// Services/IOrderService.cs
public interface IOrderService
{
    Task<OrderDto> CreateOrder(CreateOrderDto dto);
    Task<OrderDto> GetOrderById(int id);
    Task<List<OrderDto>> GetAllOrders();
    Task UpdateOrder(int id, UpdateOrderDto dto);
    Task DeleteOrder(int id);
}

// Services/OrderService.cs
public class OrderService : IOrderService
{
    private readonly IOrderRepository _repository;
    private readonly IMapper _mapper;
    
    // All methods in one file - gets messy!
    public async Task<OrderDto> CreateOrder(CreateOrderDto dto) { ... }
    public async Task<OrderDto> GetOrderById(int id) { ... }
    public async Task<List<OrderDto>> GetAllOrders() { ... }
    // ... more methods
}
```

#### New CQRS Pattern:

##### COMPLETE EXAMPLE: Creating an Order (Command)

**Step 1: Define what data you need**
```csharp
// Application/Commands/Orders/CreateOrder/CreateOrderCommand.cs
using MediatR;

namespace YourProject.Application.Commands.Orders.CreateOrder;

public class CreateOrderCommand : IRequest<CreateOrderResponse>
{
    public string CustomerName { get; set; }
    public string CustomerEmail { get; set; }
    public string ShippingAddress { get; set; }
    public List<OrderItemDto> Items { get; set; }
}

public class OrderItemDto
{
    public int ProductId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}

public class CreateOrderResponse
{
    public int OrderId { get; set; }
    public string OrderNumber { get; set; }
    public decimal Total { get; set; }
    public string Message { get; set; }
}
```

**Step 2: Define validation rules**
```csharp
// Application/Commands/Orders/CreateOrder/CreateOrderCommandValidator.cs
using FluentValidation;
using Microsoft.EntityFrameworkCore;
using YourProject.Application.Common.Interfaces;

namespace YourProject.Application.Commands.Orders.CreateOrder;

public class CreateOrderCommandValidator : AbstractValidator<CreateOrderCommand>
{
    private readonly IApplicationDbContext _context;
    
    public CreateOrderCommandValidator(IApplicationDbContext context)
    {
        _context = context;
        
        // Customer name is required and max 100 characters
        RuleFor(x => x.CustomerName)
            .NotEmpty().WithMessage("Customer name is required")
            .MaximumLength(100).WithMessage("Customer name cannot exceed 100 characters");
        
        // Email validation
        RuleFor(x => x.CustomerEmail)
            .NotEmpty().WithMessage("Email is required")
            .EmailAddress().WithMessage("Invalid email format");
        
        // Shipping address validation
        RuleFor(x => x.ShippingAddress)
            .NotEmpty().WithMessage("Shipping address is required")
            .MinimumLength(10).WithMessage("Please provide a complete address");
        
        // Must have at least one item
        RuleFor(x => x.Items)
            .NotEmpty().WithMessage("Order must have at least one item")
            .Must(items => items != null && items.Any())
            .WithMessage("Order must contain at least one item");
        
        // Validate each item
        RuleForEach(x => x.Items).ChildRules(item =>
        {
            item.RuleFor(x => x.ProductId)
                .GreaterThan(0).WithMessage("Invalid product ID");
            
            item.RuleFor(x => x.Quantity)
                .GreaterThan(0).WithMessage("Quantity must be at least 1")
                .LessThanOrEqualTo(100).WithMessage("Cannot order more than 100 items at once");
            
            item.RuleFor(x => x.Price)
                .GreaterThan(0).WithMessage("Price must be greater than zero");
        });
        
        // Custom validation - Check if products exist
        RuleFor(x => x.Items)
            .MustAsync(async (items, cancellation) => 
            {
                var productIds = items.Select(i => i.ProductId).Distinct();
                var existingProductIds = await _context.Products
                    .Where(p => productIds.Contains(p.Id))
                    .Select(p => p.Id)
                    .ToListAsync(cancellation);
                
                return productIds.Count() == existingProductIds.Count;
            })
            .WithMessage("One or more products do not exist");
    }
}
```

**Step 3: Handle the command (COMPLETE Implementation)**
```csharp
// Application/Commands/Orders/CreateOrder/CreateOrderCommandHandler.cs
using MediatR;
using Microsoft.EntityFrameworkCore;
using YourProject.Domain.Entities;
using YourProject.Application.Common.Interfaces;
using YourProject.Application.Common.Exceptions;

namespace YourProject.Application.Commands.Orders.CreateOrder;

public class CreateOrderCommandHandler : IRequestHandler<CreateOrderCommand, CreateOrderResponse>
{
    private readonly IApplicationDbContext _context;
    private readonly ILogger<CreateOrderCommandHandler> _logger;
    
    public CreateOrderCommandHandler(
        IApplicationDbContext context,
        ILogger<CreateOrderCommandHandler> logger)
    {
        _context = context;
        _logger = logger;
    }
    
    public async Task<CreateOrderResponse> Handle(
        CreateOrderCommand request, 
        CancellationToken cancellationToken)
    {
        try
        {
            // Calculate total from items
            var subtotal = request.Items.Sum(item => item.Quantity * item.Price);
            
            // Create domain entity (business rules are enforced here)
            var order = new Order(
                request.CustomerName,
                request.CustomerEmail,
                request.ShippingAddress,
                subtotal);
            
            // Generate order number (example: ORD-2024-000001)
            var orderCount = await _context.Orders.CountAsync(cancellationToken);
            order.SetOrderNumber($"ORD-{DateTime.Now.Year}-{(orderCount + 1):D6}");
            
            // Add order items
            foreach (var item in request.Items)
            {
                // Fetch product to verify it exists and get current price
                var product = await _context.Products
                    .FirstOrDefaultAsync(p => p.Id == item.ProductId, cancellationToken);
                
                if (product == null)
                {
                    throw new NotFoundException(nameof(Product), item.ProductId);
                }
                
                // Check stock availability
                if (product.StockQuantity < item.Quantity)
                {
                    throw new BusinessRuleException(
                        $"Insufficient stock for product {product.Name}. " +
                        $"Available: {product.StockQuantity}, Requested: {item.Quantity}");
                }
                
                // Create order item
                var orderItem = new OrderItem(
                    order.Id,
                    product.Id,
                    product.Name,
                    item.Quantity,
                    product.Price  // Use current product price
                );
                
                order.AddItem(orderItem);
                
                // Update product stock
                product.ReduceStock(item.Quantity);
            }
            
            // Add to database
            _context.Orders.Add(order);
            
            // Save changes
            await _context.SaveChangesAsync(cancellationToken);
            
            _logger.LogInformation(
                "Order {OrderNumber} created successfully for customer {CustomerName}", 
                order.OrderNumber, 
                order.CustomerName);
            
            // Return response
            return new CreateOrderResponse
            {
                OrderId = order.Id,
                OrderNumber = order.OrderNumber,
                Total = order.Total,
                Message = "Order created successfully"
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating order for customer {CustomerName}", 
                request.CustomerName);
            throw;
        }
    }
}
```

##### COMPLETE EXAMPLE: Deleting an Order (Command with Validation)

**Step 1: Define the delete command**
```csharp
// Application/Commands/Orders/DeleteOrder/DeleteOrderCommand.cs
using MediatR;

namespace YourProject.Application.Commands.Orders.DeleteOrder;

public class DeleteOrderCommand : IRequest<Unit>  // Unit = returns nothing
{
    public int OrderId { get; set; }
    public string Reason { get; set; }  // Why are we deleting?
    public bool ForceDelete { get; set; } = false;  // Force delete even if shipped
}
```

**Step 2: Validate the delete operation**
```csharp
// Application/Commands/Orders/DeleteOrder/DeleteOrderCommandValidator.cs
using FluentValidation;
using Microsoft.EntityFrameworkCore;
using YourProject.Application.Common.Interfaces;

namespace YourProject.Application.Commands.Orders.DeleteOrder;

public class DeleteOrderCommandValidator : AbstractValidator<DeleteOrderCommand>
{
    private readonly IApplicationDbContext _context;
    
    public DeleteOrderCommandValidator(IApplicationDbContext context)
    {
        _context = context;
        
        // Order ID must be valid
        RuleFor(x => x.OrderId)
            .GreaterThan(0).WithMessage("Invalid order ID");
        
        // Check if order exists
        RuleFor(x => x.OrderId)
            .MustAsync(async (orderId, cancellation) =>
            {
                return await _context.Orders
                    .AnyAsync(o => o.Id == orderId, cancellation);
            })
            .WithMessage("Order not found. Cannot delete non-existent order.");
        
        // Reason is required for audit trail
        RuleFor(x => x.Reason)
            .NotEmpty().WithMessage("Please provide a reason for deletion")
            .MinimumLength(10).WithMessage("Reason must be at least 10 characters")
            .MaximumLength(500).WithMessage("Reason cannot exceed 500 characters");
        
        // Custom validation - Check order status
        RuleFor(x => x)
            .MustAsync(async (command, cancellation) =>
            {
                var order = await _context.Orders
                    .FirstOrDefaultAsync(o => o.Id == command.OrderId, cancellation);
                
                if (order == null) return true; // Will be caught by exists check
                
                // If force delete is true, allow deletion
                if (command.ForceDelete) return true;
                
                // Otherwise, only allow deletion of pending or cancelled orders
                return order.Status == OrderStatus.Pending || 
                       order.Status == OrderStatus.Cancelled;
            })
            .WithMessage("Cannot delete order that has been shipped or delivered. " +
                        "Use ForceDelete=true to override (requires admin permission).");
    }
}
```

**Step 3: Handle the delete command**
```csharp
// Application/Commands/Orders/DeleteOrder/DeleteOrderCommandHandler.cs
using MediatR;
using Microsoft.EntityFrameworkCore;
using YourProject.Application.Common.Interfaces;
using YourProject.Application.Common.Exceptions;
using YourProject.Domain.Entities;

namespace YourProject.Application.Commands.Orders.DeleteOrder;

public class DeleteOrderCommandHandler : IRequestHandler<DeleteOrderCommand, Unit>
{
    private readonly IApplicationDbContext _context;
    private readonly ILogger<DeleteOrderCommandHandler> _logger;
    
    public DeleteOrderCommandHandler(
        IApplicationDbContext context,
        ILogger<DeleteOrderCommandHandler> logger)
    {
        _context = context;
        _logger = logger;
    }
    
    public async Task<Unit> Handle(
        DeleteOrderCommand request, 
        CancellationToken cancellationToken)
    {
        // Fetch the order with related items
        var order = await _context.Orders
            .Include(o => o.Items)
            .FirstOrDefaultAsync(o => o.Id == request.OrderId, cancellationToken);
        
        // Double-check order exists (validator should catch this)
        if (order == null)
        {
            throw new NotFoundException(nameof(Order), request.OrderId);
        }
        
        // Check if we can delete based on business rules
        if (!request.ForceDelete)
        {
            if (order.Status == OrderStatus.Shipped || order.Status == OrderStatus.Delivered)
            {
                throw new BusinessRuleException(
                    $"Cannot delete order {order.OrderNumber} with status {order.Status}. " +
                    "Order has already been processed.");
            }
        }
        
        // If order has items, restore stock before deletion
        if (order.Items.Any())
        {
            foreach (var item in order.Items)
            {
                var product = await _context.Products
                    .FirstOrDefaultAsync(p => p.Id == item.ProductId, cancellationToken);
                
                if (product != null)
                {
                    // Restore stock quantity
                    product.IncreaseStock(item.Quantity);
                    _logger.LogInformation(
                        "Restored {Quantity} units of {ProductName} to stock", 
                        item.Quantity, 
                        product.Name);
                }
            }
        }
        
        // Create audit log entry (optional but recommended)
        var auditLog = new AuditLog
        {
            EntityName = nameof(Order),
            EntityId = order.Id,
            Action = "DELETE",
            Reason = request.Reason,
            DeletedData = JsonSerializer.Serialize(order), // Store deleted data
            DeletedBy = "CurrentUser", // Get from ICurrentUserService
            DeletedAt = DateTime.UtcNow
        };
        _context.AuditLogs.Add(auditLog);
        
        // Remove the order (cascade delete will remove items)
        _context.Orders.Remove(order);
        
        // Save changes
        await _context.SaveChangesAsync(cancellationToken);
        
        _logger.LogWarning(
            "Order {OrderNumber} (ID: {OrderId}) deleted. Reason: {Reason}", 
            order.OrderNumber, 
            order.Id, 
            request.Reason);
        
        return Unit.Value;  // Return nothing (successful completion)
    }
}
```

##### For Getting an Order (Query):

**Step 1: Define what you're looking for**
```csharp
// Application/Queries/Orders/GetOrderById/GetOrderByIdQuery.cs
using MediatR;

namespace YourProject.Application.Queries.Orders.GetOrderById;

public class GetOrderByIdQuery : IRequest<OrderDetailsDto>
{
    public int OrderId { get; set; }
}
```

**Step 2: Define what you return**
```csharp
// Application/Queries/Orders/GetOrderById/OrderDetailsDto.cs
namespace YourProject.Application.Queries.Orders.GetOrderById;

public class OrderDetailsDto
{
    public int Id { get; set; }
    public string CustomerName { get; set; }
    public decimal Total { get; set; }
    public string Status { get; set; }
    public DateTime CreatedAt { get; set; }
    public List<OrderItemDto> Items { get; set; }
}

public class OrderItemDto
{
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}
```

**Step 3: Handle the query**
```csharp
// Application/Queries/Orders/GetOrderById/GetOrderByIdQueryHandler.cs
using MediatR;
using Microsoft.EntityFrameworkCore;
using AutoMapper;
using YourProject.Application.Common.Interfaces;
using YourProject.Application.Common.Exceptions;

namespace YourProject.Application.Queries.Orders.GetOrderById;

public class GetOrderByIdQueryHandler : IRequestHandler<GetOrderByIdQuery, OrderDetailsDto>
{
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;
    
    public GetOrderByIdQueryHandler(IApplicationDbContext context, IMapper mapper)
    {
        _context = context;
        _mapper = mapper;
    }
    
    public async Task<OrderDetailsDto> Handle(GetOrderByIdQuery request, CancellationToken cancellationToken)
    {
        // Find the order
        var order = await _context.Orders
            .Include(o => o.Items)  // Include related data
            .FirstOrDefaultAsync(o => o.Id == request.OrderId, cancellationToken);
        
        // Check if found
        if (order == null)
        {
            throw new NotFoundException($"Order with ID {request.OrderId} not found");
        }
        
        // Map to DTO and return
        return _mapper.Map<OrderDetailsDto>(order);
    }
}
```

---

### Phase 4: Set Up Database Context

#### 🚨 **IMPORTANT: Why We REMOVE Repository Interfaces**

In CQRS, **you DON'T need IRepository interfaces anymore!** Here's why:

##### **Problems with Repository Pattern in Modern Apps:**
```csharp
// ❌ OLD WAY - Unnecessary abstraction
public interface IOrderRepository
{
    Task<Order> GetByIdAsync(int id);
    Task<List<Order>> GetAllAsync();
    Task<List<Order>> GetPendingOrdersAsync();
    Task<List<Order>> GetOrdersByCustomerAsync(int customerId);
    Task<Order> GetOrderWithItemsAsync(int id);
    Task<decimal> GetTotalSalesAsync(DateTime from, DateTime to);
    // ... keeps growing with every new query need!
}

public class OrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;
    
    // Implementing 20+ methods that are used only once
    // Lots of boilerplate code
    // Hard to optimize specific queries
}
```

##### **Why Repository Pattern is Redundant with EF Core:**

1. **DbContext IS already a repository AND unit of work**
   - DbSet<T> provides all CRUD operations
   - SaveChangesAsync() handles transactions
   - Change tracking is built-in

2. **Each query is different**
   - You can't predict all query combinations
   - Repository methods proliferate endlessly
   - Generic repositories don't work for complex queries

3. **CQRS handlers ARE your query-specific "repositories"**
   - Each handler is focused on ONE operation
   - Optimized for that specific use case
   - No unused methods cluttering interfaces

##### **✅ NEW WAY - Direct DbContext with CQRS:**

**Step 1: Define ONE simple interface**
```csharp
// Application/Common/Interfaces/IApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using YourProject.Domain.Entities;

namespace YourProject.Application.Common.Interfaces;

public interface IApplicationDbContext
{
    // Just expose DbSets - that's all you need!
    DbSet<Order> Orders { get; }
    DbSet<OrderItem> OrderItems { get; }
    DbSet<Product> Products { get; }
    DbSet<Customer> Customers { get; }
    DbSet<AuditLog> AuditLogs { get; }
    
    Task<int> SaveChangesAsync(CancellationToken cancellationToken);
}
```

**Step 2: Use DbContext directly in handlers**
```csharp
// Application/Queries/Orders/GetPendingOrders/GetPendingOrdersQueryHandler.cs
public class GetPendingOrdersQueryHandler : IRequestHandler<GetPendingOrdersQuery, List<OrderDto>>
{
    private readonly IApplicationDbContext _context;
    
    public async Task<List<OrderDto>> Handle(
        GetPendingOrdersQuery request, 
        CancellationToken cancellationToken)
    {
        // Direct, optimized query - no repository needed!
        return await _context.Orders
            .Where(o => o.Status == OrderStatus.Pending)
            .Where(o => o.CreatedAt >= DateTime.UtcNow.AddDays(-7))
            .OrderByDescending(o => o.Total)
            .Select(o => new OrderDto
            {
                Id = o.Id,
                CustomerName = o.CustomerName,
                Total = o.Total,
                DaysOld = (DateTime.UtcNow - o.CreatedAt).Days
            })
            .ToListAsync(cancellationToken);
    }
}
```

##### **Comparison: Repository vs CQRS**

| Aspect | Repository Pattern | CQRS with DbContext |
|--------|-------------------|---------------------|
| **Abstraction** | Unnecessary layer | Direct and simple |
| **Query Methods** | Pre-defined, rigid | Flexible, specific |
| **Performance** | Generic, hard to optimize | Optimized per query |
| **Code Location** | Scattered in repositories | Organized in handlers |
| **Testing** | Mock repository | Mock DbContext |
| **Maintenance** | Repository grows huge | Each handler isolated |

##### **But What About Testing?**

**Testing is EASIER without repositories:**
```csharp
// Test Example - Mocking IApplicationDbContext
[Test]
public async Task CreateOrder_Should_Succeed()
{
    // Arrange
    var context = new Mock<IApplicationDbContext>();
    var orders = new List<Order>();
    var mockSet = CreateMockDbSet(orders);
    
    context.Setup(c => c.Orders).Returns(mockSet.Object);
    context.Setup(c => c.SaveChangesAsync(It.IsAny<CancellationToken>()))
           .ReturnsAsync(1);
    
    var handler = new CreateOrderCommandHandler(context.Object);
    
    // Act
    var result = await handler.Handle(new CreateOrderCommand 
    { 
        CustomerName = "Test" 
    }, CancellationToken.None);
    
    // Assert
    Assert.That(orders.Count, Is.EqualTo(1));
}

// Or use In-Memory Database for integration tests
[Test]
public async Task GetOrders_Should_Return_Filtered_Results()
{
    // Arrange
    var options = new DbContextOptionsBuilder<ApplicationDbContext>()
        .UseInMemoryDatabase(databaseName: "TestDb")
        .Options;
    
    using var context = new ApplicationDbContext(options);
    
    // Seed test data
    context.Orders.Add(new Order("Customer1", "email@test.com", "Address", 100));
    await context.SaveChangesAsync();
    
    var handler = new GetOrdersQueryHandler(context);
    
    // Act & Assert
    var result = await handler.Handle(new GetOrdersQuery(), CancellationToken.None);
    Assert.That(result.Count, Is.EqualTo(1));
}
```

##### **When MIGHT You Still Want a Repository?**

Only in these RARE cases:
1. **Complex domain logic** that's reused across multiple handlers
2. **Multiple data sources** (SQL + MongoDB + Redis)
3. **Legacy system** migration where you need to abstract the data layer

For 95% of applications, you DON'T need repositories with CQRS!

##### **What About Specification Pattern?**

If you need reusable query logic, use **Specification Pattern** instead:
```csharp
// Application/Common/Specifications/OrderSpecifications.cs
public static class OrderSpecifications
{
    public static IQueryable<Order> WhereIsPending(this IQueryable<Order> query)
    {
        return query.Where(o => o.Status == OrderStatus.Pending);
    }
    
    public static IQueryable<Order> WhereCustomerIs(
        this IQueryable<Order> query, 
        string customerName)
    {
        return query.Where(o => o.CustomerName.Contains(customerName));
    }
}

// Use in handler
var orders = await _context.Orders
    .WhereIsPending()
    .WhereCustomerIs("John")
    .ToListAsync();
```

**Step 3: Implement the context**
```csharp
// Persistence/Context/ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using YourProject.Application.Common.Interfaces;
using YourProject.Domain.Entities;

namespace YourProject.Persistence.Context;

public class ApplicationDbContext : DbContext, IApplicationDbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
    
    public DbSet<Order> Orders { get; set; }
    public DbSet<Product> Products { get; set; }
    public DbSet<Customer> Customers { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Apply all configurations from this assembly
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
        
        base.OnModelCreating(modelBuilder);
    }
    
    public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        // You can add audit fields here
        foreach (var entry in ChangeTracker.Entries<BaseEntity>())
        {
            if (entry.State == EntityState.Added)
            {
                entry.Entity.CreatedAt = DateTime.UtcNow;
            }
            else if (entry.State == EntityState.Modified)
            {
                entry.Entity.UpdatedAt = DateTime.UtcNow;
            }
        }
        
        return base.SaveChangesAsync(cancellationToken);
    }
}
```

**Step 3: Configure entity mappings**
```csharp
// Persistence/Configurations/OrderConfiguration.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using YourProject.Domain.Entities;

namespace YourProject.Persistence.Configurations;

public class OrderConfiguration : IEntityTypeConfiguration<Order>
{
    public void Configure(EntityTypeBuilder<Order> builder)
    {
        // Table name
        builder.ToTable("Orders");
        
        // Primary key
        builder.HasKey(o => o.Id);
        
        // Properties
        builder.Property(o => o.CustomerName)
            .IsRequired()
            .HasMaxLength(100);
        
        builder.Property(o => o.Total)
            .HasPrecision(18, 2);
        
        builder.Property(o => o.Status)
            .HasConversion<string>()  // Store enum as string
            .HasMaxLength(50);
        
        // Relationships
        builder.HasMany(o => o.Items)
            .WithOne(i => i.Order)
            .HasForeignKey(i => i.OrderId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}
```

---

### Phase 5: Update Controllers

#### Old Controller:
```csharp
[ApiController]
[Route("api/[controller]")]
public class OrderController : ControllerBase
{
    private readonly IOrderService _orderService;
    
    public OrderController(IOrderService orderService)
    {
        _orderService = orderService;
    }
    
    [HttpPost]
    public async Task<IActionResult> Create(CreateOrderDto dto)
    {
        var result = await _orderService.CreateOrder(dto);
        return Ok(result);
    }
    
    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(int id)
    {
        var result = await _orderService.GetOrderById(id);
        return Ok(result);
    }
}
```

#### New Controller with MediatR:
```csharp
using MediatR;
using Microsoft.AspNetCore.Mvc;
using YourProject.Application.Commands.Orders.CreateOrder;
using YourProject.Application.Commands.Orders.UpdateOrder;
using YourProject.Application.Commands.Orders.DeleteOrder;
using YourProject.Application.Queries.Orders.GetOrderById;
using YourProject.Application.Queries.Orders.GetAllOrders;

namespace YourProject.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class OrderController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<OrderController> _logger;
    
    public OrderController(IMediator mediator, ILogger<OrderController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }
    
    /// <summary>
    /// Create a new order
    /// </summary>
    [HttpPost]
    [ProducesResponseType(typeof(CreateOrderResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<CreateOrderResponse>> Create([FromBody] CreateOrderCommand command)
    {
        _logger.LogInformation("Creating new order for customer: {CustomerName}", command.CustomerName);
        
        var result = await _mediator.Send(command);
        
        // Return 201 Created with location header
        return CreatedAtAction(
            nameof(GetById), 
            new { id = result.OrderId }, 
            result);
    }
    
    /// <summary>
    /// Get order by ID
    /// </summary>
    [HttpGet("{id}")]
    [ProducesResponseType(typeof(OrderDetailsDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<OrderDetailsDto>> GetById(int id)
    {
        var query = new GetOrderByIdQuery { OrderId = id };
        var order = await _mediator.Send(query);
        return Ok(order);
    }
    
    /// <summary>
    /// Get all orders with optional filtering
    /// </summary>
    [HttpGet]
    [ProducesResponseType(typeof(List<OrderListDto>), StatusCodes.Status200OK)]
    public async Task<ActionResult<List<OrderListDto>>> GetAll(
        [FromQuery] string customerName = null,
        [FromQuery] OrderStatus? status = null,
        [FromQuery] int pageNumber = 1,
        [FromQuery] int pageSize = 10)
    {
        var query = new GetAllOrdersQuery 
        { 
            CustomerName = customerName,
            Status = status,
            PageNumber = pageNumber,
            PageSize = pageSize
        };
        
        var orders = await _mediator.Send(query);
        return Ok(orders);
    }
    
    /// <summary>
    /// Update an order
    /// </summary>
    [HttpPut("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Update(int id, [FromBody] UpdateOrderCommand command)
    {
        if (id != command.OrderId)
        {
            return BadRequest("Order ID mismatch");
        }
        
        await _mediator.Send(command);
        return NoContent();
    }
    
    /// <summary>
    /// Delete an order (with validation)
    /// </summary>
    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Delete(
        int id, 
        [FromQuery] string reason,
        [FromQuery] bool forceDelete = false)
    {
        if (string.IsNullOrWhiteSpace(reason))
        {
            return BadRequest("Deletion reason is required");
        }
        
        var command = new DeleteOrderCommand 
        { 
            OrderId = id,
            Reason = reason,
            ForceDelete = forceDelete
        };
        
        await _mediator.Send(command);
        
        _logger.LogWarning("Order {OrderId} deleted. Reason: {Reason}", id, reason);
        
        return NoContent();
    }
    
    /// <summary>
    /// Cancel an order
    /// </summary>
    [HttpPost("{id}/cancel")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Cancel(int id, [FromBody] CancelOrderCommand command)
    {
        command.OrderId = id;
        await _mediator.Send(command);
        return NoContent();
    }
    
    /// <summary>
    /// Mark order as shipped
    /// </summary>
    [HttpPost("{id}/ship")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Ship(int id, [FromBody] ShipOrderCommand command)
    {
        command.OrderId = id;
        await _mediator.Send(command);
        return NoContent();
    }
}
```

---

### Phase 6: Dependency Injection Setup

#### Application Layer DI:
```csharp
// Application/DependencyInjection.cs
using System.Reflection;
using FluentValidation;
using MediatR;
using Microsoft.Extensions.DependencyInjection;

namespace YourProject.Application;

public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        // Add AutoMapper
        services.AddAutoMapper(Assembly.GetExecutingAssembly());
        
        // Add FluentValidation validators
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        
        // Add MediatR
        services.AddMediatR(cfg => {
            cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
            cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
        });
        
        return services;
    }
}
```

#### Persistence Layer DI:
```csharp
// Persistence/DependencyInjection.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using YourProject.Application.Common.Interfaces;
using YourProject.Persistence.Context;

namespace YourProject.Persistence;

public static class DependencyInjection
{
    public static IServiceCollection AddPersistence(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Add DbContext
        services.AddDbContext<ApplicationDbContext>(options =>
            options.UseSqlServer(
                configuration.GetConnectionString("DefaultConnection"),
                b => b.MigrationsAssembly(typeof(ApplicationDbContext).Assembly.FullName)));
        
        // Register DbContext as IApplicationDbContext
        services.AddScoped<IApplicationDbContext>(provider =>
            provider.GetRequiredService<ApplicationDbContext>());
        
        return services;
    }
}
```

#### Program.cs:
```csharp
// API/Program.cs
using YourProject.Application;
using YourProject.Persistence;

var builder = WebApplication.CreateBuilder(args);

// Add layers
builder.Services.AddApplication();
builder.Services.AddPersistence(builder.Configuration);

// Add API services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseCors("AllowAll");

// Add custom middleware
app.UseMiddleware<ErrorHandlingMiddleware>();

app.UseAuthorization();
app.MapControllers();

app.Run();
```

---

## Common Patterns

### 1. Custom Exceptions
```csharp
// Application/Common/Exceptions/NotFoundException.cs
namespace YourProject.Application.Common.Exceptions;

public class NotFoundException : Exception
{
    public NotFoundException()
        : base()
    {
    }

    public NotFoundException(string message)
        : base(message)
    {
    }

    public NotFoundException(string message, Exception innerException)
        : base(message, innerException)
    {
    }

    public NotFoundException(string name, object key)
        : base($"Entity \"{name}\" ({key}) was not found.")
    {
    }
}

// Application/Common/Exceptions/BusinessRuleException.cs
namespace YourProject.Application.Common.Exceptions;

public class BusinessRuleException : Exception
{
    public string Code { get; }
    
    public BusinessRuleException(string message, string code = null)
        : base(message)
    {
        Code = code;
    }
}

// Application/Common/Exceptions/ValidationException.cs
using FluentValidation.Results;

namespace YourProject.Application.Common.Exceptions;

public class ValidationException : Exception
{
    public ValidationException()
        : base("One or more validation failures have occurred.")
    {
        Errors = new Dictionary<string, string[]>();
    }

    public ValidationException(IEnumerable<ValidationFailure> failures)
        : this()
    {
        Errors = failures
            .GroupBy(e => e.PropertyName, e => e.ErrorMessage)
            .ToDictionary(failureGroup => failureGroup.Key, failureGroup => failureGroup.ToArray());
    }

    public IDictionary<string, string[]> Errors { get; }
}
```

### 2. Validation Behavior (Automatic Validation)
```csharp
// Application/Common/Behaviors/ValidationBehavior.cs
using FluentValidation;
using MediatR;

namespace YourProject.Application.Common.Behaviors;

public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;
    
    public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)
    {
        _validators = validators;
    }
    
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        if (_validators.Any())
        {
            var context = new ValidationContext<TRequest>(request);
            
            var validationResults = await Task.WhenAll(
                _validators.Select(v => v.ValidateAsync(context, cancellationToken)));
            
            var failures = validationResults
                .SelectMany(r => r.Errors)
                .Where(f => f != null)
                .ToList();
            
            if (failures.Count != 0)
            {
                throw new ValidationException(failures);
            }
        }
        
        return await next();
    }
}
```

### 3. Logging Behavior (Automatic Request/Response Logging)
```csharp
// Application/Common/Behaviors/LoggingBehavior.cs
using System.Diagnostics;
using MediatR;
using Microsoft.Extensions.Logging;

namespace YourProject.Application.Common.Behaviors;

public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;
    
    public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    {
        _logger = logger;
    }
    
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        var stopwatch = Stopwatch.StartNew();
        
        _logger.LogInformation(
            "Handling {RequestName} ({@Request})",
            requestName, request);
        
        try
        {
            var response = await next();
            
            stopwatch.Stop();
            
            _logger.LogInformation(
                "Handled {RequestName} in {ElapsedMilliseconds}ms",
                requestName, stopwatch.ElapsedMilliseconds);
            
            return response;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            
            _logger.LogError(ex,
                "Error handling {RequestName} after {ElapsedMilliseconds}ms",
                requestName, stopwatch.ElapsedMilliseconds);
            
            throw;
        }
    }
}
```

### 4. Error Handling Middleware
```csharp
// API/Middleware/ErrorHandlingMiddleware.cs
using System.Net;
using System.Text.Json;
using FluentValidation;
using YourProject.Application.Common.Exceptions;

namespace YourProject.API.Middleware;

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;
    
    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred");
            await HandleExceptionAsync(context, ex);
        }
    }
    
    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var statusCode = HttpStatusCode.InternalServerError;
        var result = string.Empty;
        
        switch (exception)
        {
            case ValidationException validationException:
                statusCode = HttpStatusCode.BadRequest;
                result = JsonSerializer.Serialize(new
                {
                    errors = validationException.Errors.Select(e => new
                    {
                        property = e.PropertyName,
                        message = e.ErrorMessage
                    })
                });
                break;
                
            case NotFoundException:
                statusCode = HttpStatusCode.NotFound;
                result = JsonSerializer.Serialize(new { message = exception.Message });
                break;
                
            default:
                result = JsonSerializer.Serialize(new { message = "An error occurred" });
                break;
        }
        
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = (int)statusCode;
        await context.Response.WriteAsync(result);
    }
}
```

### 3. AutoMapper Profiles - WHERE DO THEY GO?

#### Location and Organization

**Mapping profiles should go in the APPLICATION layer**, specifically in:
```
Application/
├── Common/
│   └── Mappings/
│       ├── MappingProfile.cs           (Base/Main profile)
│       ├── OrderMappingProfile.cs      (Order-specific mappings)
│       ├── ProductMappingProfile.cs    (Product-specific mappings)
│       └── CustomerMappingProfile.cs   (Customer-specific mappings)
```

#### Why in the Application Layer?
- **DTOs live in Application**: Since DTOs are defined in the Application layer (in Query folders), mappings should be there too
- **Domain stays pure**: Domain layer shouldn't know about DTOs or mapping
- **Centralized location**: All mappings in one place make them easier to find and maintain

#### Option 1: Single Mapping Profile (Small Projects)
```csharp
// Application/Common/Mappings/MappingProfile.cs
using AutoMapper;
using YourProject.Domain.Entities;
using YourProject.Application.Queries.Orders.GetOrderById;
using YourProject.Application.Queries.Orders.GetAllOrders;
using YourProject.Application.Queries.Products.GetProduct;

namespace YourProject.Application.Common.Mappings;

public class MappingProfile : Profile
{
    public MappingProfile()
    {
        // Order mappings
        CreateMap<Order, OrderDetailsDto>()
            .ForMember(dest => dest.Status, 
                opt => opt.MapFrom(src => src.Status.ToString()))
            .ForMember(dest => dest.TotalWithTax,
                opt => opt.MapFrom(src => src.Total * 1.15m));
        
        CreateMap<Order, OrderListDto>()
            .ForMember(dest => dest.ItemCount,
                opt => opt.MapFrom(src => src.Items.Count));
        
        CreateMap<OrderItem, OrderItemDto>();
        
        // Product mappings
        CreateMap<Product, ProductDto>();
        CreateMap<Product, ProductListDto>();
        
        // Customer mappings
        CreateMap<Customer, CustomerDto>()
            .ForMember(dest => dest.FullName,
                opt => opt.MapFrom(src => $"{src.FirstName} {src.LastName}"));
    }
}
```

#### Option 2: Separate Profiles by Feature (Large Projects)
```csharp
// Application/Common/Mappings/OrderMappingProfile.cs
using AutoMapper;
using YourProject.Domain.Entities;
using YourProject.Application.Queries.Orders.GetOrderById;
using YourProject.Application.Queries.Orders.GetAllOrders;

namespace YourProject.Application.Common.Mappings;

public class OrderMappingProfile : Profile
{
    public OrderMappingProfile()
    {
        // Map to detailed DTO (for single order query)
        CreateMap<Order, OrderDetailsDto>()
            .ForMember(dest => dest.Status, 
                opt => opt.MapFrom(src => src.Status.ToString()))
            .ForMember(dest => dest.CustomerFullName,
                opt => opt.MapFrom(src => src.Customer != null 
                    ? $"{src.Customer.FirstName} {src.Customer.LastName}" 
                    : src.CustomerName))
            .ForMember(dest => dest.TotalWithTax,
                opt => opt.MapFrom(src => CalculateTotalWithTax(src.Total)))
            .ForMember(dest => dest.FormattedOrderNumber,
                opt => opt.MapFrom(src => $"#{src.OrderNumber}"));
        
        // Map to list DTO (for list query - less data)
        CreateMap<Order, OrderListDto>()
            .ForMember(dest => dest.ItemCount,
                opt => opt.MapFrom(src => src.Items.Count))
            .ForMember(dest => dest.StatusBadgeColor,
                opt => opt.MapFrom(src => GetStatusColor(src.Status)));
        
        // Map order items
        CreateMap<OrderItem, OrderItemDto>()
            .ForMember(dest => dest.LineTotal,
                opt => opt.MapFrom(src => src.Quantity * src.Price));
        
        // Reverse mappings (if needed for updates)
        CreateMap<UpdateOrderDto, Order>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());
    }
    
    private static decimal CalculateTotalWithTax(decimal total)
    {
        const decimal taxRate = 0.15m; // 15% tax
        return total * (1 + taxRate);
    }
    
    private static string GetStatusColor(OrderStatus status)
    {
        return status switch
        {
            OrderStatus.Pending => "yellow",
            OrderStatus.Shipped => "blue",
            OrderStatus.Delivered => "green",
            OrderStatus.Cancelled => "red",
            _ => "gray"
        };
    }
}
```

#### Option 3: Interface-based Mapping (Advanced)
```csharp
// Application/Common/Mappings/IMapFrom.cs
using AutoMapper;

namespace YourProject.Application.Common.Mappings;

public interface IMapFrom<T>
{
    void Mapping(Profile profile) => profile.CreateMap(typeof(T), GetType());
}

// Application/Queries/Orders/GetOrderById/OrderDetailsDto.cs
using YourProject.Application.Common.Mappings;
using YourProject.Domain.Entities;

namespace YourProject.Application.Queries.Orders.GetOrderById;

public class OrderDetailsDto : IMapFrom<Order>
{
    public int Id { get; set; }
    public string OrderNumber { get; set; }
    public string CustomerName { get; set; }
    public decimal Total { get; set; }
    public string Status { get; set; }
    public DateTime CreatedAt { get; set; }
    public List<OrderItemDto> Items { get; set; }
    
    // Custom mapping configuration
    public void Mapping(Profile profile)
    {
        profile.CreateMap<Order, OrderDetailsDto>()
            .ForMember(dest => dest.Status,
                opt => opt.MapFrom(src => src.Status.ToString()));
    }
}
```

#### Registering AutoMapper
```csharp
// Application/DependencyInjection.cs
using System.Reflection;
using Microsoft.Extensions.DependencyInjection;

namespace YourProject.Application;

public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        // Register AutoMapper with all profiles from this assembly
        services.AddAutoMapper(Assembly.GetExecutingAssembly());
        
        // Or register specific profiles
        services.AddAutoMapper(cfg =>
        {
            cfg.AddProfile<OrderMappingProfile>();
            cfg.AddProfile<ProductMappingProfile>();
            cfg.AddProfile<CustomerMappingProfile>();
        });
        
        return services;
    }
}
```

---

## Tips and Best Practices

### Do's ✅

1. **Keep handlers small**: Each handler should do ONE thing
2. **Use meaningful names**: `CreateOrderCommand` is better than `OrderCommand`
3. **Validate early**: Use FluentValidation to catch errors before processing
4. **Return appropriate status codes**: 201 for created, 204 for no content, etc.
5. **Use cancellation tokens**: Pass them through all async operations
6. **Test each handler independently**: Much easier than testing services
7. **Keep domain logic in entities**: Business rules belong in the domain layer
8. **Use DbContext directly**: No need for repository abstraction

### Don'ts ❌

1. **Don't put business logic in handlers**: Keep it in domain entities
2. **Don't return domain entities from API**: Always use DTOs
3. **Don't share DTOs between queries**: Each query should have its own DTO
4. **Don't make commands return complex objects**: Keep them simple (IDs, success/fail)
5. **Don't inject repositories in controllers**: Use MediatR instead
6. **Don't forget validation**: Every command should have a validator
7. **DON'T create IRepository interfaces**: DbContext is already a repository
8. **DON'T abstract DbContext unnecessarily**: IApplicationDbContext is enough

---

## Migration Checklist

- [ ] Create new solution structure with 4 projects
- [ ] Install all required NuGet packages
- [ ] Set up project references correctly
- [ ] Move models to Domain/Entities
- [ ] Add business logic to entities
- [ ] Create command for each write operation
- [ ] Create query for each read operation
- [ ] Add validators for all commands
- [ ] Set up DbContext and configurations
- [ ] Configure AutoMapper profiles in Application/Common/Mappings
- [ ] Update controllers to use MediatR
- [ ] Set up dependency injection
- [ ] Add error handling middleware
- [ ] **DELETE all IRepository interfaces** ❌
- [ ] **DELETE all Repository implementations** ❌
- [ ] **Replace repository calls with direct DbContext usage** ✅
- [ ] Test each endpoint
- [ ] Remove old service/repository files

---

## Example Migration Timeline

### Week 1: Setup
- Create project structure
- Set up dependencies
- Configure basic infrastructure

### Week 2: Domain & Persistence
- Migrate models to entities
- Set up DbContext
- Configure entity mappings

### Week 3: Commands
- Create all command handlers
- Add validation
- Test write operations

### Week 4: Queries
- Create all query handlers
- Set up DTOs and mappings
- Test read operations

### Week 5: Cleanup & Testing
- Remove old code
- Complete integration testing
- Deploy to staging

---

## Troubleshooting Common Issues

### Issue 1: "Cannot resolve IApplicationDbContext"
**Solution**: Make sure you registered it in DependencyInjection.cs and added the project reference.

### Issue 2: "Validation not working"
**Solution**: Check that ValidationBehavior is registered in MediatR pipeline.

### Issue 3: "AutoMapper mapping not found"
**Solution**: Ensure your mapping profile is in the Application project and inherits from Profile.

### Issue 4: "Handler not found"
**Solution**: Make sure your handler implements IRequestHandler and is in the Application project.

### Issue 5: "Migration fails"
**Solution**: Check connection string and ensure EF Core tools are installed.

---

## Frequently Asked Questions (FAQ)

### ❓ **"Do I need IRepository interfaces with CQRS?"**
**NO!** This is the most common misconception. Entity Framework's DbContext already implements the repository and unit of work patterns. Adding another repository layer is redundant and adds unnecessary complexity.

### ❓ **"But how do I test without repositories?"**
You have three options:
1. **Mock IApplicationDbContext** for unit tests
2. **Use In-Memory Database** for integration tests  
3. **Use SQLite in-memory** for more realistic tests

All are simpler than mocking complex repository interfaces!

### ❓ **"Where do I put complex queries?"**
Directly in your Query Handlers! Each handler is responsible for ONE query, optimized for that specific use case. If you have reusable query logic, use extension methods or specification pattern.

### ❓ **"What if I need to switch databases later?"**
Entity Framework already abstracts the database. You can switch from SQL Server to PostgreSQL by just changing the connection string and provider. You don't need repositories for this.

### ❓ **"My team insists on using repositories. What do I do?"**
Show them this guide! But if you MUST use repositories:
- Keep them thin (just wrap DbContext)
- Make them specific, not generic
- Consider it technical debt to remove later

### ❓ **"Where do AutoMapper profiles go?"**
In `Application/Common/Mappings/` folder. They belong in the Application layer because that's where your DTOs live.

### ❓ **"Can I use the same DTO for multiple queries?"**
It's better not to. Each query should have its own DTO to avoid breaking changes affecting multiple features. The extra code is worth the decoupling.

---

## Resources

- [MediatR Documentation](https://github.com/jbogard/MediatR)
- [FluentValidation Documentation](https://fluentvalidation.net/)
- [AutoMapper Documentation](https://automapper.org/)
- [Clean Architecture by Jason Taylor](https://github.com/jasontaylordev/CleanArchitecture)
- [CQRS Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)

---

## Summary

You're transforming your code from a traditional layered architecture to a modern, scalable CQRS pattern. This gives you:

- **Better organization**: Each feature in its own folder
- **Easier testing**: Test handlers independently
- **Clear separation**: Commands write, Queries read
- **Better teamwork**: Less merge conflicts
- **Scalability**: Can optimize reads and writes separately
- **Less code**: NO repository interfaces needed!

### 🎉 **The Big Win: Removing Repositories!**

One of the best parts of CQRS is that **you DELETE all your IRepository interfaces and Repository classes!** 

**Before (Traditional)**: Controller → Service → IRepository → Repository → DbContext → Database

**After (CQRS)**: Controller → MediatR → Handler → DbContext → Database

That's 2 fewer layers of abstraction! Your code becomes simpler, more direct, and easier to understand.

Remember: Start small, migrate one feature at a time, and test as you go!

---

## Quick Reference: Where Everything Goes

### 📁 **Domain Layer** (YourProject.Domain)
- **Entities**: Core business objects with business logic
- **Value Objects**: Complex types (Address, Money, etc.)
- **Enums**: OrderStatus, UserRole, etc.
- **Domain Events**: Things that happened in the system
- **Domain Exceptions**: Business rule violations

### 📁 **Application Layer** (YourProject.Application)
- **Commands**: Write operations (Create, Update, Delete)
  - `CreateOrderCommand.cs` - Data structure
  - `CreateOrderCommandHandler.cs` - Processing logic
  - `CreateOrderCommandValidator.cs` - Validation rules
- **Queries**: Read operations (Get, List, Search)
  - `GetOrderByIdQuery.cs` - What to search for
  - `GetOrderByIdQueryHandler.cs` - How to find it
  - `OrderDetailsDto.cs` - What to return
- **Common/Interfaces**: `IApplicationDbContext.cs`
- **Common/Mappings**: AutoMapper profiles
- **Common/Behaviors**: Cross-cutting concerns (validation, logging)
- **Common/Exceptions**: Application-specific exceptions

### 📁 **Persistence Layer** (YourProject.Persistence)
- **Context**: `ApplicationDbContext.cs`
- **Configurations**: Entity Framework configurations
- **Migrations**: Database schema changes
- **Seeds**: Initial data

### 📁 **API Layer** (YourProject.API)
- **Controllers**: HTTP endpoints
- **Middleware**: Request/response processing
- **Extensions**: Helper methods
- **Filters**: Action filters, exception filters
- **Program.cs**: Application startup

### 🔄 **Migration Mapping**
| Your Current File | Goes To | New Location |
|-------------------|---------|--------------|
| `Models/Order.cs` | Domain Entity | `Domain/Entities/Order.cs` |
| `DTOs/OrderDto.cs` | Query DTO | `Application/Queries/GetOrder/OrderDto.cs` |
| `Services/OrderService.cs` | Command/Query Handlers | `Application/Commands/` & `Application/Queries/` |
| `IServices/IOrderService.cs` | ❌ DELETE | Replaced by MediatR |
| `Repositories/OrderRepository.cs` | ❌ DELETE | Use DbContext directly |
| `IRepositories/IOrderRepository.cs` | ❌ DELETE | Use IApplicationDbContext |
| AutoMapper Profiles | Application Layer | `Application/Common/Mappings/` |
| Validators | With Commands | `Application/Commands/[Feature]/[Command]Validator.cs` |

### 📊 **Repository to CQRS Migration Example**

#### ❌ BEFORE - With Repository:
```csharp
// IRepositories/IOrderRepository.cs
public interface IOrderRepository
{
    Task<Order> GetOrderWithItemsByIdAsync(int id);
    Task<List<Order>> GetOrdersByCustomerAsync(string customerName);
}

// Repositories/OrderRepository.cs
public class OrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;
    
    public async Task<Order> GetOrderWithItemsByIdAsync(int id)
    {
        return await _context.Orders
            .Include(o => o.Items)
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    
    public async Task<List<Order>> GetOrdersByCustomerAsync(string customerName)
    {
        return await _context.Orders
            .Where(o => o.CustomerName.Contains(customerName))
            .ToListAsync();
    }
}

// Services/OrderService.cs
public class OrderService : IOrderService
{
    private readonly IOrderRepository _repository;
    
    public async Task<OrderDto> GetOrderById(int id)
    {
        var order = await _repository.GetOrderWithItemsByIdAsync(id);
        return MapToDto(order);
    }
}
```

#### ✅ AFTER - Direct DbContext in CQRS:
```csharp
// Application/Common/Interfaces/IApplicationDbContext.cs
public interface IApplicationDbContext
{
    DbSet<Order> Orders { get; }
    DbSet<OrderItem> OrderItems { get; }
    Task<int> SaveChangesAsync(CancellationToken cancellationToken);
}

// Application/Queries/GetOrderById/GetOrderByIdQueryHandler.cs
public class GetOrderByIdQueryHandler : IRequestHandler<GetOrderByIdQuery, OrderDto>
{
    private readonly IApplicationDbContext _context;
    
    public async Task<OrderDto> Handle(GetOrderByIdQuery request, CancellationToken cancellationToken)
    {
        // Direct query - no repository needed!
        var order = await _context.Orders
            .Include(o => o.Items)
            .Where(o => o.Id == request.OrderId)
            .Select(o => new OrderDto
            {
                Id = o.Id,
                CustomerName = o.CustomerName,
                Items = o.Items.Select(i => new OrderItemDto
                {
                    ProductName = i.ProductName,
                    Quantity = i.Quantity
                }).ToList()
            })
            .FirstOrDefaultAsync(cancellationToken);
            
        if (order == null)
            throw new NotFoundException(nameof(Order), request.OrderId);
            
        return order;
    }
}
```

**See the difference?** No repository layer, direct optimized queries, and each handler has exactly the query it needs!

---

## Remember This! 🎯

1. **Commands** = Change things (Create, Update, Delete)
2. **Queries** = Read things (Get, List, Search)
3. **Handlers** = Do the work (one handler per command/query)
4. **Validators** = Check the rules (one validator per command)
5. **DTOs** = Data shapes for queries (one DTO per query)
6. **Entities** = Business objects with rules (in Domain layer)
7. **MediatR** = The messenger (connects controllers to handlers)
8. **AutoMapper** = The translator (entities ↔ DTOs)