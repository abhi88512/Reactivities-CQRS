# Section 20: Implementing Followers and Following Feature

## Introduction to Followers and Following

### Definition
The followers and following feature allows users in a social networking application to follow other users and be followed, creating a self-referencing many-to-many relationship between users.

### Purpose
This feature enhances the social aspect of the application, enabling users to track others' activities and display social connections (e.g., followers count) in user profiles and activity details.

### Key Idea
A self-referencing many-to-many relationship is managed through a join table (`UserFollowing`) to track which users follow others and who follows them.

> **Analogy**: Think of the followers system like a subscription to a magazine. One user (the subscriber) can follow many others (magazines), and each user (magazine) can have many subscribers.

## Learning Goals
- **Understand Self-Referencing Relationships**: Learn how to model a many-to-many relationship between users using a join table.
- **Implement Follow Toggle**: Create functionality to allow users to follow or unfollow others.
- **Display Followers/Following Lists**: Build UI components to show lists of followers and those being followed.
- **Integrate with API and Client**: Connect the backend API with the React frontend to enable real-time updates to follower status.

## Self-Referencing Many-to-Many Relationship

### Definition
A self-referencing many-to-many relationship occurs when an entity (e.g., `User`) relates to itself, allowing each user to follow multiple users and be followed by multiple users.

### Implementation
- **Join Table (`UserFollowing`)**: A table to store relationships between users, with `ObserverId` (the follower) and `TargetId` (the followed user).
- **User Entity Update**: Add two collections (`Followings` and `Followers`) to the `User` class to represent outgoing and incoming follow relationships.

### Code Example (UserFollowing Entity)
```csharp
public class UserFollowing
{
    public required string ObserverId { get; set; }
    public User? Observer { get; set; }
    public required string TargetId { get; set; }
    public User? Target { get; set; }
}
```

### Code Example (User Entity Update)
```csharp
public class User
{
    public string Id { get; set; } = null!;
    // Other properties...
    public ICollection<UserFollowing> Followings { get; set; } = new List<UserFollowing>();
    public ICollection<UserFollowing> Followers { get; set; } = new List<UserFollowing>();
}
```

### Code Example (DbContext Configuration)
```csharp
public class AppDbContext : DbContext
{
    public DbSet<UserFollowing> UserFollowings { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.Entity<UserFollowing>(x =>
        {
            x.HasKey(k => new { k.ObserverId, k.TargetId });
            x.HasOne(f => f.Observer)
                .WithMany(u => u.Followings)
                .HasForeignKey(o => o.ObserverId)
                .OnDelete(DeleteBehavior.Cascade);
            x.HasOne(f => f.Target)
                .WithMany(u => u.Followers)
                .HasForeignKey(o => o.TargetId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
}
```

### Create Migration
```bash
dotnet ef migrations add FollowerEntityAdded -p Persistence -s API
```

## Backend Implementation

### Follow Toggle Handler
- **Purpose**: Allows users to toggle following/unfollowing another user.
- **Logic**:
  - Check if the target user exists.
  - Check if a following relationship exists; if so, remove it; if not, add it.
  - Save changes to the database.

```csharp
public class FollowToggle
{
    public class Command : IRequest<Result<Unit>>
    {
        public required string TargetUserId { get; set; }
    }

    public class Handler : IRequestHandler<Command, Result<Unit>>
    {
        private readonly AppDbContext _context;
        private readonly IUserAccessor _userAccessor;

        public Handler(AppDbContext context, IUserAccessor userAccessor)
        {
            _context = context;
            _userAccessor = userAccessor;
        }

        public async Task<Result<Unit>> Handle(Command request, CancellationToken cancellationToken)
        {
            var observer = await _userAccessor.GetUserAsync();
            var target = await _context.Users.FindAsync([request.TargetUserId], cancellationToken);
            if (target == null)
                return Result<Unit>.Failure("Target user not found", 400);

            var following = await _context.UserFollowings
                .FindAsync([observer.Id, target.Id], cancellationToken);

            if (following == null)
            {
                _context.UserFollowings.Add(new UserFollowing
                {
                    ObserverId = observer.Id,
                    TargetId = target.Id
                });
            }
            else
            {
                _context.UserFollowings.Remove(following);
            }

            var result = await _context.SaveChangesAsync(cancellationToken) > 0;
            return result ? Result<Unit>.Success(Unit.Value) : Result<Unit>.Failure("Problem updating following", 400);
        }
    }
}
```

### Get Followings Handler
- **Purpose**: Retrieves a list of followers or followings for a user.
- **Logic**:
  - Use a predicate (`followers` or `followings`) to determine which list to fetch.
  - Project the results to `UserProfile` DTOs using AutoMapper.

```csharp
public class GetFollowings
{
    public class Query : IRequest<Result<List<UserProfile>>>
    {
        public required string Predicate { get; set; } = "followers";
        public required string UserId { get; set; }
    }

    public class Handler : IRequestHandler<Query, Result<List<UserProfile>>>
    {
        private readonly AppDbContext _context;
        private readonly IMapper _mapper;
        private readonly IUserAccessor _userAccessor;

        public Handler(AppDbContext context, IMapper mapper, IUserAccessor userAccessor)
        {
            _context = context;
            _mapper = mapper;
            _userAccessor = userAccessor;
        }

        public async Task<Result<List<UserProfile>>> Handle(Query request, CancellationToken cancellationToken)
        {
            var profiles = new List<UserProfile>();

            switch (request.Predicate)
            {
                case "followers":
                    profiles = await _context.UserFollowings
                        .Where(x => x.TargetId == request.UserId)
                        .Select(x => x.Observer)
                        .ProjectTo<UserProfile>(_mapper.ConfigurationProvider, new { currentUserId = _userAccessor.GetUserId() })
                        .ToListAsync(cancellationToken);
                    break;
                case "followings":
                    profiles = await _context.UserFollowings
                        .Where(x => x.ObserverId == request.UserId)
                        .Select(x => x.Target)
                        .ProjectTo<UserProfile>(_mapper.ConfigurationProvider, new { currentUserId = _userAccessor.GetUserId() })
                        .ToListAsync(cancellationToken);
                    break;
            }

            return Result<List<UserProfile>>.Success(profiles);
        }
    }
}
```

### Profiles Controller
- **Endpoints**:
  - `POST /api/profiles/{userId}/follow`: Toggle following a user.
  - `GET /api/profiles/{userId}/followlist?predicate={predicate}`: Get followers or followings list.

```csharp
[Route("api/profiles")]
public class ProfilesController : BaseApiController
{
    [HttpPost("{userId}/follow")]
    public async Task<ActionResult> FollowToggle(string userId)
    {
        return HandleResult(await Mediator.Send(new FollowToggle.Command { TargetUserId = userId }));
    }

    [HttpGet("{userId}/followlist")]
    public async Task<ActionResult> GetFollowings(string userId, string predicate)
    {
        return HandleResult(await Mediator.Send(new GetFollowings.Query { UserId = userId, Predicate = predicate }));
    }
}
```

### AutoMapper Configuration
- **Purpose**: Map `User` to `UserProfile` with additional properties (`Following`, `FollowersCount`, `FollowingCount`).
- **Key Point**: Pass the current user ID to check if the current user follows the profile.

```csharp
public class MappingProfiles : Profile
{
    public MappingProfiles()
    {
        string? currentUserId = null;
        CreateMap<User, UserProfile>()
            .ForMember(d => d.FollowersCount, o => o.MapFrom(s => s.Followers.Count))
            .ForMember(d => d.FollowingCount, o => o.MapFrom(s => s.Followings.Count))
            .ForMember(d => d.Following, o => o.MapFrom(s => s.Followers.Any(x => x.ObserverId == currentUserId)));
    }
}
```

## Client-Side Implementation (React)

### Update Profile Type
- Add new properties to the `Profile` type.
```typescript
export type Profile = {
    id: string;
    displayName: string;
    // Other properties...
    followersCount?: number;
    followingCount?: number;
    following?: boolean;
};
```

### Update UseProfile Hook
- Add a query to fetch followers or followings and a mutation to toggle following.
```typescript
export const useProfile = (id?: string, predicate?: string) => {
    const queryClient = useQueryClient();

    const { data: profile, isLoading: loadingProfile } = useQuery({
        queryKey: ["profile", id],
        queryFn: async () => {
            const response = await agent.get<Profile>(`/profiles/${id}`);
            return response.data;
        },
        enabled: !!id && !predicate,
    });

    const { data: followings, isLoading: loadingFollowings } = useQuery({
        queryKey: ["followings", id, predicate],
        queryFn: async () => {
            const response = await agent.get<Profile[]>(`/profiles/${id}/followlist?predicate=${predicate}`);
            return response.data;
        },
        enabled: !!id && !!predicate,
    });

    const updateFollowing = useMutation({
        mutationFn: async () => {
            await agent.post(`/profiles/${id}/follow`);
        },
        onSuccess: () => {
            queryClient.setQueryData(["profile", id], (profile: Profile | undefined) => {
                if (!profile || profile.followersCount === undefined) return profile;
                return {
                    ...profile,
                    following: !profile.following,
                    followersCount: profile.following ? profile.followersCount - 1 : profile.followersCount + 1,
                };
            });
            queryClient.invalidateQueries({ queryKey: ["followings", id, "followers"] });
        },
    });

    return { profile, loadingProfile, followings, loadingFollowings, updateFollowing, isCurrentUser };
};
```

### Profile Followings Component
- Display a list of followers or followings based on the active tab.
```typescript
import { Box, Typography, Divider } from "@mui/material";
import { useParams } from "react-router-dom";
import { useProfile } from "../../lib/hooks/useProfile";
import ProfileCard from "./ProfileCard";

type Props = {
    activeTab: number;
};

export default function ProfileFollowings({ activeTab }: Props) {
    const { id } = useParams();
    const predicate = activeTab === 3 ? "followers" : "followings";
    const { profile, followings, loadingFollowings } = useProfile(id, predicate);

    return (
        <Box>
            <Box display="flex">
                <Typography variant="h5">
                    {activeTab === 3 ? `People following ${profile?.displayName}` : `People ${profile?.displayName} is following`}
                </Typography>
            </Box>
            <Divider sx={{ my: 2 }} />
            {loadingFollowings ? (
                <Typography>Loading...</Typography>
            ) : (
                <Box display="flex" mt={3} gap={3}>
                    {followings?.map((profile) => (
                        <ProfileCard key={profile.id} profile={profile} />
                    ))}
                </Box>
            )}
        </Box>
    );
}
```

### Update Profile Header
- Use the `useProfile` hook to toggle following and display updated counts.
```typescript
import { Box, Button, Divider, Typography } from "@mui/material";
import { useParams } from "react-router-dom";
import { useProfile } from "../../lib/hooks/useProfile";

export default function ProfileHeader() {
    const { id } = useParams();
    const { profile, isCurrentUser, updateFollowing } = useProfile(id);

    if (!profile) return null;

    return (
        <Box>
            <Typography>{profile.displayName}</Typography>
            <Typography>{profile.followersCount} followers</Typography>
            <Typography>{profile.followingCount} following</Typography>
            {!isCurrentUser && (
                <>
                    <Divider />
                    <Button
                        onClick={() => updateFollowing.mutate()}
                        disabled={updateFollowing.isPending}
                        color={profile.following ? "error" : "primary"}
                    >
                        {profile.following ? "Unfollow" : "Follow"}
                    </Button>
                </>
            )}
        </Box>
    );
}
```

### Update Avatar Popover
- Add a border to indicate if the user is being followed.
```typescript
import { Avatar } from "@mui/material";

export default function AvatarPopover({ profile }: { profile: Profile }) {
    return (
        <Avatar
            src={profile.imageUrl}
            alt="user"
            sx={{ border: profile.following ? 3 : 0, borderColor: "secondary.main" }}
        />
    );
}
```

## Key Commands Recap
- **Create Migration**:
  ```bash
  dotnet ef migrations add FollowerEntityAdded -p Persistence -s API
  ```
- **Drop Database (if needed)**:
  ```bash
  dotnet ef database drop -p Persistence -s API
  ```

## Tips for Beginners
- **Self-Referencing Relationships**: Use clear naming (e.g., `ObserverId` and `TargetId`) to distinguish roles in the relationship to avoid confusion.
- **AutoMapper Configuration**: Be cautious with property names (e.g., `currentUserId`) as they are not type-safe and require exact spelling.
- **React Query Invalidation**: Use `invalidateQueries` to refresh follower lists after toggling to ensure UI consistency.
- **Test with Postman**: Hardcode user IDs for testing to simplify API calls, but ensure to reset the database if changing user IDs.

## Next Steps
- Test the followers/following functionality by logging in as different users and verifying UI updates (e.g., border colors, follower counts).
- Consider adding a placeholder message (e.g., "No followers yet") when the followers/following list is empty.
- Commit changes to source control to save progress.